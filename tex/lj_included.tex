% generated by Ott 0.25 from: lj_common.ott lj_base.ott lj.ott
\newcommand{\ljdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ljdrulename{#4}}}
\newcommand{\ljusedrule}[1]{\[#1\]}
\newcommand{\ljpremise}[1]{ #1 \\}
\newenvironment{ljdefnblock}[3][]{ \framebox{\mbox{#2}} \quad #3 \\[0pt]}{}
\newenvironment{ljfundefnblock}[3][]{ \framebox{\mbox{#2}} \quad #3 \\[0pt]\begin{displaymath}\begin{array}{l}}{\end{array}\end{displaymath}}
\newcommand{\ljfunclause}[2]{ #1 \equiv #2 \\}
\newcommand{\ljnt}[1]{\mathit{#1}}
\newcommand{\ljmv}[1]{\mathit{#1}}
\newcommand{\ljkw}[1]{\mathbf{#1}}
\newcommand{\ljsym}[1]{#1}
\newcommand{\ljcom}[1]{\text{#1}}
\newcommand{\ljdrulename}[1]{\textsc{#1}}
\newcommand{\ljcomplu}[5]{\overline{#1}^{\,#2\in #3 #4 #5}}
\newcommand{\ljcompu}[3]{\overline{#1}^{\,#2<#3}}
\newcommand{\ljcomp}[2]{\overline{#1}^{\,#2}}
\newcommand{\ljgrammartabular}[1]{\begin{supertabular}{llcllllll}#1\end{supertabular}}
\newcommand{\ljmetavartabular}[1]{\begin{supertabular}{ll}#1\end{supertabular}}
\newcommand{\ljrulehead}[3]{$#1$ & & $#2$ & & & \multicolumn{2}{l}{#3}}
\newcommand{\ljprodline}[6]{& & $#1$ & $#2$ & $#3 #4$ & $#5$ & $#6$}
\newcommand{\ljfirstprodline}[6]{\ljprodline{#1}{#2}{#3}{#4}{#5}{#6}}
\newcommand{\ljlongprodline}[2]{& & $#1$ & \multicolumn{4}{l}{$#2$}}
\newcommand{\ljfirstlongprodline}[2]{\ljlongprodline{#1}{#2}}
\newcommand{\ljbindspecprodline}[6]{\ljprodline{#1}{#2}{#3}{#4}{#5}{#6}}
\newcommand{\ljprodnewline}{\\}
\newcommand{\ljinterrule}{\\[5.0mm]}
\newcommand{\ljafterlastrule}{\\}
\newcommand{\ljmetavars}{
\ljmetavartabular{
 $ \ljmv{j} ,\, \ljmv{k} ,\, \ljmv{l} $ & \ljcom{index} \\
 $ \ljmv{f} $ & \ljcom{field name} \\
 $ \ljmv{meth} $ & \ljcom{method name} \\
 $ \ljmv{var} $ & \ljcom{term variable} \\
 $ \ljmv{dcl} $ & \ljcom{name of derived class} \\
 $ \ljmv{oid} $ & \ljcom{object identifier} \\
}}

\newcommand{\ljterminals}{
\ljrulehead{\ljnt{terminals}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{ (\! }{}{}{}{\ljcom{left expression bracket}}\ljprodnewline
\ljprodline{|}{ \!) }{}{}{}{\ljcom{right expression bracket}}\ljprodnewline
\ljprodline{|}{ [\! }{}{}{}{\ljcom{left environment bracket}}\ljprodnewline
\ljprodline{|}{ \!] }{}{}{}{\ljcom{right environment bracket}}\ljprodnewline
\ljprodline{|}{ \!, }{}{}{}{\ljcom{separator}}\ljprodnewline
\ljprodline{|}{ / }{}{}{}{\ljcom{`replaces'}}\ljprodnewline
\ljprodline{|}{ \!\!:\!\! }{}{}{}{\ljcom{`is of type'}}\ljprodnewline
\ljprodline{|}{ \!\!\prec\! }{}{}{}{\ljcom{`is a subtype of'}}\ljprodnewline
\ljprodline{|}{ \rightarrow }{}{}{}{\ljcom{`returns'}}\ljprodnewline
\ljprodline{|}{ \mapsto }{}{}{}{\ljcom{`maps to'}}\ljprodnewline
\ljprodline{|}{ \longrightarrow }{}{}{}{\ljcom{`reduces'}}\ljprodnewline
\ljprodline{|}{ \Rightarrow }{}{}{}{\ljcom{`results in'}}\ljprodnewline
\ljprodline{|}{ \!=\! }{}{}{}{\ljcom{equality or alias}}\ljprodnewline
\ljprodline{|}{ \!==\! }{}{}{}{\ljcom{`is equal to'}}\ljprodnewline
\ljprodline{|}{ \neq }{}{}{}{\ljcom{`is not equal to'}}\ljprodnewline
\ljprodline{|}{ \vdash }{}{}{}{\ljcom{`can deduce'}}\ljprodnewline
\ljprodline{|}{ \forall\! }{}{}{}{\ljcom{`for all'}}\ljprodnewline
\ljprodline{|}{ \exists\! }{}{}{}{\ljcom{`there exists'}}\ljprodnewline
\ljprodline{|}{ \!\in\! }{}{}{}{\ljcom{`in'}}\ljprodnewline
\ljprodline{|}{ \!\notin\! }{}{}{}{\ljcom{`not in'}}\ljprodnewline
\ljprodline{|}{ \vee }{}{}{}{\ljcom{`or'}}\ljprodnewline
\ljprodline{|}{ \wedge }{}{}{}{\ljcom{`and'}}\ljprodnewline
\ljprodline{|}{ \bot }{}{}{}{\ljcom{`is disjoint from'}}\ljprodnewline
\ljprodline{|}{ \leadsto }{}{}{}{\ljcom{`is translated to'}}}

\newcommand{\ljx}{
\ljrulehead{\ljnt{x}  ,\ \ljnt{y}}{::=}{\ljcom{term variable}}\ljprodnewline
\ljfirstprodline{|}{\ljmv{var}}{}{}{}{\ljcom{normal variable}}\ljprodnewline
\ljprodline{|}{\ljkw{this}}{}{}{}{\ljcom{keyword}}\ljprodnewline
\ljprodline{|}{\theta  (\!  \ljnt{x}  \!)} {\textsf{M}}{}{}{\ljcom{translate $\ljnt{x}$ with $\theta$}}}

\newcommand{\ljX}{
\ljrulehead{\overline{x}  ,\ \overline{y}}{::=}{\ljcom{term variables}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{x_{{\mathrm{1}}}} \, .. \, \ljnt{x_{\ljmv{k}}}} {\textsf{M}}{}{}{\ljcom{def}}}

\newcommand{\ljcl}{
\ljrulehead{\ljnt{cl}}{::=}{\ljcom{class name}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{Object}}{}{}{}{\ljcom{top class}}\ljprodnewline
\ljprodline{|}{\ljnt{fqn}}{}{}{}{\ljcom{fully qualified name}}}

\newcommand{\ljfd}{
\ljrulehead{\ljnt{fd}}{::=}{\ljcom{field declaration}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{cl} \, \ljmv{f}  \ljsym{;}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljfds}{
\ljrulehead{\overline{fd}}{::=}{\ljcom{field declarations}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{fd_{{\mathrm{1}}}} \, .. \, \ljnt{fd_{\ljmv{k}}}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljfs}{
\ljrulehead{\overline{f}}{::=}{\ljcom{fields}}\ljprodnewline
\ljfirstprodline{|}{\ljmv{f_{{\mathrm{1}}}} \, .. \, \ljmv{f_{\ljmv{k}}}} {\textsf{M}}{}{}{\ljcom{def.}}\ljprodnewline
\ljprodline{|}{\overline{f}  \ljsym{;}  \overline{f}'} {\textsf{M}}{}{}{\ljcom{append}}}

\newcommand{\ljfsXXopt}{
\ljrulehead{\overline{f}_{opt}}{::=}{\ljcom{fields option}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{null}}{}{}{}{\ljcom{none}}\ljprodnewline
\ljprodline{|}{\overline{f}}{}{}{}{\ljcom{some}}}

\newcommand{\ljs}{
\ljrulehead{\ljnt{s}}{::=}{\ljcom{statement}}\ljprodnewline
\ljfirstprodline{|}{\ljsym{\{} \, \ljcomp{\ljnt{s_{\ljmv{k}}}}{\ljmv{k}} \, \ljsym{\}}}{}{}{}{\ljcom{block}}\ljprodnewline
\ljprodline{|}{\ljmv{var}  \!=\!  \ljnt{x}  \ljsym{;}}{}{}{}{\ljcom{variable assignment}}\ljprodnewline
\ljprodline{|}{\ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{f}  \ljsym{;}}{}{}{}{\ljcom{field read}}\ljprodnewline
\ljprodline{|}{\ljnt{x}  \ljsym{.}  \ljmv{f}  \!=\!  \ljnt{y}  \ljsym{;}}{}{}{}{\ljcom{field write}}\ljprodnewline
\ljprodline{|}{\ljkw{if} \, (\!  \ljnt{x}  \!==\!  \ljnt{y}  \!)  \ljnt{s} \, \ljkw{else} \, \ljnt{s'}}{}{}{}{\ljcom{conditional branch}}\ljprodnewline
\ljprodline{|}{\ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{meth}  (\!  \overline{y}  \!)  \ljsym{;}}{}{}{}{\ljcom{method call}}\ljprodnewline
\ljprodline{|}{ \ljmv{var} = \ljkw{new} _{ \ljnt{ctx} } \ljnt{cl} (); }{}{}{}{\ljcom{object creation}}}

\newcommand{\ljvd}{
\ljrulehead{\ljnt{vd}}{::=}{\ljcom{variable declaration}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{cl} \, \ljmv{var}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljvds}{
\ljrulehead{\overline{vd}}{::=}{\ljcom{variable declarations}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{vd_{{\mathrm{1}}}} \, .. \, \ljnt{vd_{\ljmv{k}}}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljmethXXsig}{
\ljrulehead{\ljnt{meth\_sig}}{::=}{\ljcom{method sig.}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{cl} \, \ljmv{meth}  (\!  \overline{vd}  \!)}{}{}{}{\ljcom{def.}}}

\newcommand{\ljmethXXbody}{
\ljrulehead{\ljnt{meth\_body}}{::=}{\ljcom{method body}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{s_{{\mathrm{1}}}} \, .. \, \ljnt{s_{\ljmv{k}}} \, \ljkw{return} \, \ljnt{y}  \ljsym{;}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljmethXXdef}{
\ljrulehead{\ljnt{meth\_def}}{::=}{\ljcom{method def.}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{meth\_sig}  \ljsym{\{}  \ljnt{meth\_body}  \ljsym{\}}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljmethXXdefs}{
\ljrulehead{\overline{meth\_def}}{::=}{\ljcom{method def.'s}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{meth\_def_{{\mathrm{1}}}} \, .. \, \ljnt{meth\_def_{\ljmv{k}}}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljmethXXdefXXopt}{
\ljrulehead{meth\_def_{opt}}{::=}{\ljcom{method def.~option}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{null}} {\textsf{M}}{}{}{\ljcom{none}}\ljprodnewline
\ljprodline{|}{\ljnt{meth\_def}} {\textsf{M}}{}{}{\ljcom{some}}}

\newcommand{\ljctxmethXXdefXXopt}{
\ljrulehead{ctxmeth\_def_{opt}}{::=}{\ljcom{method def.~in context option}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{null}}{}{}{}{\ljcom{none}}\ljprodnewline
\ljprodline{|}{(\!  \ljnt{ctx}  \!,  \ljnt{meth\_def}  \!)}{}{}{}{\ljcom{some}}}

\newcommand{\ljmeths}{
\ljrulehead{\overline{meth}}{::=}{\ljcom{method names}}\ljprodnewline
\ljfirstprodline{|}{\ljmv{meth_{{\mathrm{1}}}} \, .. \, \ljmv{meth_{\ljmv{k}}}} {\textsf{M}}{}{}{\ljcom{def.}}\ljprodnewline
\ljprodline{|}{\overline{meth}  \ljsym{;}  \overline{meth}'} {\textsf{M}}{}{}{\ljcom{append}}}

\newcommand{\ljclds}{
\ljrulehead{\overline{cld}}{::=}{\ljcom{class def.'s}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{cld_{{\mathrm{1}}}} \, .. \, \ljnt{cld_{\ljmv{k}}}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljty}{
\ljrulehead{\tau}{::=}{\ljcom{type}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{Object}}{}{}{}{\ljcom{super-type of all types}}\ljprodnewline
\ljprodline{|}{ \ljnt{ctx} \hspace{-.1ex}.\hspace{-.1ex} \ljmv{dcl} }{}{}{}{\ljcom{unique class identifier}}}

\newcommand{\ljtyXXopt}{
\ljrulehead{{ \tau_{opt} }}{::=}{\ljcom{result of type lookup}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{null}} {\textsf{M}}{}{}{\ljcom{none}}\ljprodnewline
\ljprodline{|}{\tau} {\textsf{M}}{}{}{\ljcom{some}}\ljprodnewline
\ljprodline{|}{\Gamma  (\!  \ljnt{x}  \!)} {\textsf{M}}{}{}{\ljcom{static type lookup}}\ljprodnewline
\ljprodline{|}{\ljnt{H}  (\!  \ljmv{oid}  \!)} {\textsf{M}}{}{}{\ljcom{dynamic type lookup}}}

\newcommand{\ljctxcld}{
\ljrulehead{\ljnt{ctxcld}}{::=}{\ljcom{class def.~in context}}\ljprodnewline
\ljfirstprodline{|}{(\!  \ljnt{ctx}  \!,  \ljnt{cld}  \!)}{}{}{}{\ljcom{def.}}}

\newcommand{\ljctxclds}{
\ljrulehead{\overline{ctxcld}}{::=}{\ljcom{class def.'s~in context}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{ctxcld_{{\mathrm{1}}}} \, .. \, \ljnt{ctxcld_{\ljmv{k}}}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljctxcldXXopt}{
\ljrulehead{ctxcld_{opt}}{::=}{\ljcom{class def.~lookup result}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{null}}{}{}{}{\ljcom{none}}\ljprodnewline
\ljprodline{|}{\ljnt{ctxcld}}{}{}{}{\ljcom{some}}}

\newcommand{\ljctxcldsXXopt}{
\ljrulehead{\overline{ctxcld}_{opt}}{::=}{\ljcom{class def.'s lookup result}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{null}}{}{}{}{\ljcom{none}}\ljprodnewline
\ljprodline{|}{\overline{ctxcld}}{}{}{}{\ljcom{some}}}

\newcommand{\ljtys}{
\ljrulehead{\overline{\tau}}{::=}{\ljcom{types}}\ljprodnewline
\ljfirstprodline{|}{\tau_{{\mathrm{1}}} \, .. \, \tau_{\ljmv{k}}} {\textsf{M}}{}{}{\ljcom{def.}}}

\newcommand{\ljmty}{
\ljrulehead{\pi}{::=}{\ljcom{method type}}\ljprodnewline
\ljfirstprodline{|}{\overline{\tau}  \rightarrow  \tau}{}{}{}{\ljcom{def.}}}

\newcommand{\ljG}{
\ljrulehead{\Gamma}{::=}{\ljcom{type environment ($x\rightharpoonup\tau$)}}\ljprodnewline
\ljfirstprodline{|}{\Gamma  [\!  \ljnt{x}  \mapsto  \tau  \!]} {\textsf{M}}{}{}{\ljcom{maps $\ljnt{x}$ to $\tau$ in $\Gamma$}}\ljprodnewline
\ljprodline{|}{[\!  \ljnt{x_{{\mathrm{1}}}}  \mapsto  \tau_{{\mathrm{1}}} \, .. \, \ljnt{x_{\ljmv{k}}}  \mapsto  \tau_{\ljmv{k}}  \!]} {\textsf{M}}{}{}{\ljcom{type mappings}}}

\newcommand{\ljT}{
\ljrulehead{\theta}{::=}{\ljcom{variable mapping ($x\rightharpoonup y$)}}\ljprodnewline
\ljfirstprodline{|}{\theta  [\!  \ljnt{x}  \mapsto  \ljnt{y}  \!]} {\textsf{M}}{}{}{\ljcom{$\ljnt{x}$ maps to $\ljnt{y}$ in $\theta$}}\ljprodnewline
\ljprodline{|}{[\!  \ljnt{x_{{\mathrm{1}}}}  \mapsto  \ljnt{y_{{\mathrm{1}}}} \, .. \, \ljnt{x_{\ljmv{k}}}  \mapsto  \ljnt{y_{\ljmv{k}}}  \!]} {\textsf{M}}{}{}{\ljcom{variable mappings}}}

\newcommand{\ljv}{
\ljrulehead{\ljnt{v}  ,\ \ljnt{w}}{::=}{\ljcom{value}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{null}}{}{}{}{\ljcom{null value}}\ljprodnewline
\ljprodline{|}{\ljmv{oid}}{}{}{}{\ljcom{object identifier}}}

\newcommand{\ljvXXopt}{
\ljrulehead{{ v_{opt} }}{::=}{\ljcom{result of value lookup}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{v}} {\textsf{M}}{}{}{\ljcom{some}}\ljprodnewline
\ljprodline{|}{\ljnt{L}  (\!  \ljnt{x}  \!)} {\textsf{M}}{}{}{\ljcom{lookup value of local variable}}\ljprodnewline
\ljprodline{|}{\ljnt{H}  (\!  \ljmv{oid}  \!,  \ljmv{f}  \!)} {\textsf{M}}{}{}{\ljcom{lookup value of field}}}

\newcommand{\ljL}{
\ljrulehead{\ljnt{L}}{::=}{\ljcom{variable state ($x\rightharpoonup v$)}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{L}  [\!  \ljnt{x}  \mapsto  \ljnt{v}  \!]} {\textsf{M}}{}{}{\ljcom{$\ljnt{x}$ maps to $\ljnt{v}$ in $\ljnt{L}$}}\ljprodnewline
\ljprodline{|}{\ljnt{L}  [\!  \ljnt{x_{{\mathrm{1}}}}  \mapsto  \ljnt{v_{{\mathrm{1}}}} \, .. \, \ljnt{x_{\ljmv{k}}}  \mapsto  \ljnt{v_{\ljmv{k}}}  \!]} {\textsf{M}}{}{}{\ljcom{variable state mappings in $\ljnt{L}$}}}

\newcommand{\ljH}{
\ljrulehead{\ljnt{H}}{::=}{\ljcom{heap ($oid\rightharpoonup (\tau \times (f\rightharpoonup v))$)}}\ljprodnewline
\ljfirstprodline{|}{\ljnt{H}  [\!  \ljmv{oid}  \mapsto  (\!  \tau  \!,  \ljmv{f_{{\mathrm{1}}}}  \mapsto  \ljnt{v_{{\mathrm{1}}}} \, .. \, \ljmv{f_{\ljmv{k}}}  \mapsto  \ljnt{v_{\ljmv{k}}}  \!)  \!]} {\textsf{M}}{}{}{\ljcom{new $\ljmv{oid}$ of type $\tau$ in $\ljnt{H}$}}\ljprodnewline
\ljprodline{|}{\ljnt{H}  [\!  (\!  \ljmv{oid}  \!,  \ljmv{f}  \!)  \mapsto  \ljnt{v}  \!]} {\textsf{M}}{}{}{\ljcom{$\ljmv{f}$ of $\ljmv{oid}$ mapping to $\ljnt{v}$ in $\ljnt{H}$}}}

\newcommand{\ljconfig}{
\ljrulehead{\ljnt{config}}{::=}{\ljcom{configuration}}\ljprodnewline
\ljfirstprodline{|}{(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!, \, \ljcomp{\ljnt{s_{\ljmv{k}}}}{\ljmv{k}} \, \!)}{}{}{}{\ljcom{statements to execute under $\ljnt{L}$ and $\ljnt{H}$}}\ljprodnewline
\ljprodline{|}{(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljnt{Exception}  \!)}{}{}{}{\ljcom{exception occured in previous step}}}

\newcommand{\ljException}{
\ljrulehead{\ljnt{Exception}}{::=}{\ljcom{exception}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{NPE}}{}{}{}{\ljcom{null pointer exception}}\ljprodnewline
\ljprodline{|}{\ljkw{CNFE}}{}{}{}{\ljcom{class not found exception}}}

\newcommand{\ljfqn}{
\ljrulehead{\ljnt{fqn}}{::=}{\ljcom{fully qualified name}}\ljprodnewline
\ljfirstprodline{|}{\ljmv{dcl}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljcld}{
\ljrulehead{\ljnt{cld}}{::=}{\ljcom{class}}\ljprodnewline
\ljfirstprodline{|}{\ljkw{class} \, \ljmv{dcl} \, \ljkw{extends} \, \ljnt{cl}  \ljsym{\{}  \overline{fd} \, \overline{meth\_def}  \ljsym{\}}}{}{}{}{\ljcom{def.}}}

\newcommand{\ljP}{
\ljrulehead{\ljnt{P}}{::=}{\ljcom{program}}\ljprodnewline
\ljfirstprodline{|}{\overline{cld}} {\textsf{M}}{}{}{\ljcom{def.}}}

\newcommand{\ljctx}{
\ljrulehead{\ljnt{ctx}}{::=}{\ljcom{context}}\ljprodnewline
\ljfirstprodline{|}{}{}{}{}{\ljcom{no context}}}

\newcommand{\ljformula}{
\ljrulehead{\ljnt{formula}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljnt{judgement}}{}{}{}{\ljcom{judgement}}\ljprodnewline
\ljprodline{|}{\ljcomp{\ljnt{formula_{\ljmv{k}}}}{\ljmv{k}}} {\textsf{M}}{}{}{\ljcom{conjunction of formulas}}\ljprodnewline
\ljprodline{|}{ \neg  \ljnt{formula} } {\textsf{M}}{}{}{\ljcom{negated formula}}\ljprodnewline
\ljprodline{|}{ ( \ljnt{formula} \!) } {\textsf{M}}{}{}{\ljcom{bracketed}}\ljprodnewline
\ljprodline{|}{ \ljnt{formula}  \vee  \ljnt{formula'} } {\textsf{M}}{}{}{\ljcom{or}}\ljprodnewline
\ljprodline{|}{ \ljnt{formula}  \wedge  \ljnt{formula'} } {\textsf{M}}{}{}{\ljcom{and}}\ljprodnewline
\ljprodline{|}{ \ljnt{formula}  \longrightarrow  \ljnt{formula'} } {\textsf{M}}{}{}{\ljcom{implies}}\ljprodnewline
\ljprodline{|}{\ljnt{x}  \!=\!  \ljnt{x'}} {\textsf{M}}{}{}{\ljcom{variable alias}}\ljprodnewline
\ljprodline{|}{\overline{x}  \!=\!  \overline{x}'} {\textsf{M}}{}{}{\ljcom{variables alias}}\ljprodnewline
\ljprodline{|}{\overline{f}  \!=\!  \overline{f}'} {\textsf{M}}{}{}{\ljcom{fields alias}}\ljprodnewline
\ljprodline{|}{\overline{fd}  \!=\!  \overline{fd}'} {\textsf{M}}{}{}{\ljcom{field declarations alias}}\ljprodnewline
\ljprodline{|}{\overline{meth}  \!=\!  \overline{meth}'} {\textsf{M}}{}{}{\ljcom{method names alias}}\ljprodnewline
\ljprodline{|}{\ljnt{cld}  \!=\!  \ljnt{cld'}} {\textsf{M}}{}{}{\ljcom{class def.~alias}}\ljprodnewline
\ljprodline{|}{\overline{cld}  \!=\!  \overline{cld}'} {\textsf{M}}{}{}{\ljcom{class def.'s alias}}\ljprodnewline
\ljprodline{|}{\ljnt{P}  \!=\!  \ljnt{P'}} {\textsf{M}}{}{}{\ljcom{program alias}}\ljprodnewline
\ljprodline{|}{\overline{ctxcld}  \!=\!  \overline{ctxcld}'} {\textsf{M}}{}{}{\ljcom{class def.'s with context alias}}\ljprodnewline
\ljprodline{|}{\ljnt{meth\_def}  \!=\!  \ljnt{meth\_def'}} {\textsf{M}}{}{}{\ljcom{method def.~alias}}\ljprodnewline
\ljprodline{|}{\overline{\tau}  \!=\!  \overline{\tau}'} {\textsf{M}}{}{}{\ljcom{types alias}}\ljprodnewline
\ljprodline{|}{{ \tau_{opt} }  \!=\!  { \tau_{opt} }'} {\textsf{M}}{}{}{\ljcom{type option alias}}\ljprodnewline
\ljprodline{|}{\pi  \!=\!  \pi'} {\textsf{M}}{}{}{\ljcom{method type alias}}\ljprodnewline
\ljprodline{|}{\theta  \!=\!  \theta'} {\textsf{M}}{}{}{\ljcom{variable mapping alias}}\ljprodnewline
\ljprodline{|}{\ljnt{L}  \!=\!  \ljnt{L'}} {\textsf{M}}{}{}{\ljcom{variable state alias}}\ljprodnewline
\ljprodline{|}{\ljnt{H}  \!=\!  \ljnt{H'}} {\textsf{M}}{}{}{\ljcom{heap alias}}\ljprodnewline
\ljprodline{|}{\Gamma  \!=\!  \Gamma'} {\textsf{M}}{}{}{\ljcom{type environment alias}}\ljprodnewline
\ljprodline{|}{{ v_{opt} }  \!=\!  \ljnt{v}} {\textsf{M}}{}{}{\ljcom{value lookup alias}}\ljprodnewline
\ljprodline{|}{\ljnt{v}  \!==\!  \ljnt{w}} {\textsf{M}}{}{}{\ljcom{value equality}}\ljprodnewline
\ljprodline{|}{\ljnt{cl}  \neq  \ljnt{cl'}} {\textsf{M}}{}{}{\ljcom{class name inequality}}\ljprodnewline
\ljprodline{|}{\ljmv{f}  \neq  \ljmv{f'}} {\textsf{M}}{}{}{\ljcom{field name inequality}}\ljprodnewline
\ljprodline{|}{\ljmv{meth}  \neq  \ljmv{meth'}} {\textsf{M}}{}{}{\ljcom{method name inequality}}\ljprodnewline
\ljprodline{|}{\ljnt{v}  \neq  \ljnt{w}} {\textsf{M}}{}{}{\ljcom{value inequality}}\ljprodnewline
\ljprodline{|}{\tau  \neq  \tau'} {\textsf{M}}{}{}{\ljcom{type inequality}}\ljprodnewline
\ljprodline{|}{\ljcomp{\ljnt{x_{\ljmv{k}}}}{\ljmv{k}} \, \bot \, \ljkw{dom} \, (\!  \ljnt{L}  \!)} {\textsf{M}}{}{}{\ljcom{disjoint variables and domain}}\ljprodnewline
\ljprodline{|}{\overline{f} \, \bot \, \overline{f}'} {\textsf{M}}{}{}{\ljcom{disjoint field sets}}\ljprodnewline
\ljprodline{|}{\ljkw{distinct} \, (\! \, \ljcomp{\ljmv{f_{\ljmv{k}}}}{\ljmv{k}} \, \!)} {\textsf{M}}{}{}{\ljcom{distinct field names}}\ljprodnewline
\ljprodline{|}{\ljkw{distinct} \, (\! \, \ljcomp{\ljmv{var_{\ljmv{k}}}}{\ljmv{k}} \, \!)} {\textsf{M}}{}{}{\ljcom{distinct variable names}}\ljprodnewline
\ljprodline{|}{\ljkw{distinct} \, (\!  \overline{ctxcld}  \!)} {\textsf{M}}{}{}{\ljcom{distinct class def.'s with context}}\ljprodnewline
\ljprodline{|}{\ljmv{meth} \, \!\notin\! \, \overline{meth}} {\textsf{M}}{}{}{\ljcom{$\ljmv{meth}$ not in $\overline{meth}$}}\ljprodnewline
\ljprodline{|}{\ljmv{oid} \, \!\notin\! \, \ljkw{dom} \, (\!  \ljnt{H}  \!)} {\textsf{M}}{}{}{\ljcom{$\ljmv{oid}$ not in domain of $\ljnt{H}$}}\ljprodnewline
\ljprodline{|}{\ljnt{x} \, \!\notin\! \, \ljkw{dom} \, (\!  \ljnt{L}  \!)} {\textsf{M}}{}{}{\ljcom{$\ljnt{x}$ not in domain of $\ljnt{L}$}}\ljprodnewline
\ljprodline{|}{\ljnt{x} \, \!\notin\! \, \ljcomp{\ljnt{x_{\ljmv{k}}}}{\ljmv{k}}} {\textsf{M}}{}{}{\ljcom{$\ljnt{x}$ not in list}}\ljprodnewline
\ljprodline{|}{(\!  \ljnt{ctx}  \!,  \ljmv{dcl}  \!) \, \!\in\! \, \ljcomp{(\!  \ljnt{ctx_{\ljmv{k}}}  \!,  \ljmv{dcl_{\ljmv{k}}}  \!)}{\ljmv{k}}} {\textsf{M}}{}{}{\ljcom{pair in list}}\ljprodnewline
\ljprodline{|}{\exists\! \, \tau  \ljsym{.}  \ljnt{formula}} {\textsf{M}}{}{}{\ljcom{there exists a $\tau$}}\ljprodnewline
\ljprodline{|}{\exists\! \, \overline{f}  \ljsym{.}  \ljnt{formula}} {\textsf{M}}{}{}{\ljcom{there exist $\overline{f}$}}\ljprodnewline
\ljprodline{|}{\forall\! \, \ljnt{x} \, \!\in\! \, \ljkw{dom} \, (\!  \Gamma  \!)  \ljsym{.}  \ljnt{formula}} {\textsf{M}}{}{}{\ljcom{for all variables in domain of $\Gamma$}}\ljprodnewline
\ljprodline{|}{\forall\! \, \ljmv{f} \, \!\in\! \, \overline{f}  \ljsym{.}  \ljnt{formula}} {\textsf{M}}{}{}{\ljcom{for all fields in $\overline{f}$}}\ljprodnewline
\ljprodline{|}{\forall\! \, \ljmv{oid} \, \!\in\! \, \ljkw{dom} \, (\!  \ljnt{H}  \!)  \ljsym{.}  \ljnt{formula}} {\textsf{M}}{}{}{\ljcom{for all objects in domain of $\ljnt{H}$}}\ljprodnewline
\ljprodline{|}{\ljkw{distinct} \, (\!  \ljmv{dcl_{{\mathrm{1}}}} \, .. \, \ljmv{dcl_{\ljmv{k}}}  \!)} {\textsf{M}}{}{}{\ljcom{distinct class names}}\ljprodnewline
\ljprodline{|}{\ljnt{cld} \, \!\in\! \, \ljnt{P}} {\textsf{M}}{}{}{\ljcom{class definition part of the program}}}

\newcommand{\ljclassnameXXdef}{
\ljrulehead{\ljnt{classname\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljkw{classname} \, (\!  \ljnt{cld}  \!)  \!=\!  \ljmv{dcl}}{}{}{}{\ljcom{get name of class}}}

\newcommand{\ljsuperclassXXdef}{
\ljrulehead{\ljnt{superclass\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljkw{superclass} \, (\!  \ljnt{cld}  \!)  \!=\!  \ljnt{cl}}{}{}{}{\ljcom{get name of superclass}}}

\newcommand{\ljclassfieldsXXdef}{
\ljrulehead{\ljnt{classfields\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljkw{classfields} \, (\!  \ljnt{cld}  \!)  \!=\!  \overline{fd}}{}{}{}{\ljcom{get class fields}}}

\newcommand{\ljclassmethodsXXdef}{
\ljrulehead{\ljnt{classmethods\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljkw{classmethods} \, (\!  \ljnt{cld}  \!)  \!=\!  \overline{meth\_def}}{}{}{}{\ljcom{get class methods}}}

\newcommand{\ljmethodnameXXdef}{
\ljrulehead{\ljnt{methodname\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljkw{methodname} \, (\!  \ljnt{meth\_def}  \!)  \!=\!  \ljmv{meth}}{}{}{}{\ljcom{get method's name}}}

\newcommand{\ljdistinctXXnamesXXdef}{
\ljrulehead{\ljnt{distinct\_names\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{distinct\_names}  (\!  \ljnt{P}  \!)}{}{}{}{\ljcom{distinct names of type definitions}}}

\newcommand{\ljfindXXcldXXdef}{
\ljrulehead{\ljnt{find\_cld\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{find\_cld}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{fqn}  \!)  \!=\!  ctxcld_{opt}}{}{}{}{\ljcom{class def.~lookup}}}

\newcommand{\ljfindXXtypeXXdef}{
\ljrulehead{\ljnt{find\_type\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl}  \!)  \!=\!  { \tau_{opt} }}{}{}{}{\ljcom{type lookup}}}

\newcommand{\ljfindXXpathXXdef}{
\ljrulehead{\ljnt{find\_path\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl}  \!)  \!=\!  \overline{ctxcld}_{opt}}{}{}{}{\ljcom{find class hierarchy path}}}

\newcommand{\ljfindXXpathXXtyXXdef}{
\ljrulehead{\ljnt{find\_path\_ty\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{ctxcld}_{opt}}{}{}{}{\ljcom{find class hierarchy path}}}

\newcommand{\ljfieldsXXinXXpathXXdef}{
\ljrulehead{\ljnt{fields\_in\_path\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{fields\_in\_path}  (\!  \overline{cld}  \!)  \!=\!  \overline{f}}{}{}{}{\ljcom{get fields in class path}}}

\newcommand{\ljfieldsXXdef}{
\ljrulehead{\ljnt{fields\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljkw{fields} \, (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{f}_{opt}}{}{}{}{\ljcom{get all fields of $\tau$}}}

\newcommand{\ljmethodsXXinXXpathXXdef}{
\ljrulehead{\ljnt{methods\_in\_path\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{methods\_in\_path}  (\!  \overline{cld}  \!)  \!=\!  \overline{meth}}{}{}{}{\ljcom{get all method names in class path}}}

\newcommand{\ljmethodsXXdef}{
\ljrulehead{\ljnt{methods\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljkw{methods} \, (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{meth}}{}{}{}{\ljcom{get all method names of $\tau$}}}

\newcommand{\ljftypeXXinXXfdsXXdef}{
\ljrulehead{\ljnt{ftype\_in\_fds\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{ftype\_in\_fds}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \overline{fd}  \!,  \ljmv{f}  \!)  \!=\!  { \tau_{opt} }}{}{}{}{\ljcom{get class of $\ljmv{f}$ from field declarations}}}

\newcommand{\ljftypeXXinXXpathXXdef}{
\ljrulehead{\ljnt{ftype\_in\_path\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{ftype\_in\_path}  (\!  \ljnt{P}  \!,  \overline{ctxcld}  \!,  \ljmv{f}  \!)  \!=\!  { \tau_{opt} }}{}{}{}{\ljcom{get type of $\ljmv{f}$ in class path}}}

\newcommand{\ljftypeXXdef}{
\ljrulehead{\ljnt{ftype\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljkw{ftype} \, (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{f}  \!)  \!=\!  \tau'}{}{}{}{\ljcom{get type of $\ljmv{f}$ in $\tau$}}}

\newcommand{\ljfindXXmethXXdefXXinXXlistXXdef}{
\ljrulehead{\ljnt{find\_meth\_def\_in\_list\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{find\_meth\_def\_in\_list}  (\!  \overline{meth\_def}  \!,  \ljmv{meth}  \!)  \!=\!  meth\_def_{opt}}{}{}{}{\ljcom{find method def.~in list}}}

\newcommand{\ljfindXXmethXXdefXXinXXpathXXdef}{
\ljrulehead{\ljnt{find\_meth\_def\_in\_path\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{find\_meth\_def\_in\_path}  (\!  \overline{ctxcld}  \!,  \ljmv{meth}  \!)  \!=\!  ctxmeth\_def_{opt}}{}{}{}{\ljcom{find method def.~(and context) in class path}}}

\newcommand{\ljfindXXmethXXdefXXdef}{
\ljrulehead{\ljnt{find\_meth\_def\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljsym{find\_meth\_def}  (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  ctxmeth\_def_{opt}}{}{}{}{\ljcom{find method def.~(given dynamic type $\tau$)}}}

\newcommand{\ljmtypeXXdef}{
\ljrulehead{\ljnt{mtype\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljkw{mtype} \, (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  \pi}{}{}{}{\ljcom{find method type}}}

\newcommand{\ljstyXXoneXXdef}{
\ljrulehead{\ljnt{sty\_one\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljnt{P}  \vdash  \tau  \!\!\prec\!  \tau'}{}{}{}{\ljcom{subtyping}}}

\newcommand{\ljstyXXmanyXXdef}{
\ljrulehead{\ljnt{sty\_many\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljnt{P}  \vdash  \overline{\tau}  \!\!\prec\!  \overline{\tau}'}{}{}{}{\ljcom{normal, multiple subtyping}}}

\newcommand{\ljstyXXoptionXXdef}{
\ljrulehead{\ljnt{sty\_option\_def}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljnt{P}  \vdash  { \tau_{opt} }  \!\!\prec\!  { \tau_{opt} }'}{}{}{}{\ljcom{option subtyping}}}

\newcommand{\ljwellXXformedness}{
\ljrulehead{\ljnt{well\_formedness}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljnt{P}  \!,  \ljnt{H}  \vdash  { v_{opt} }  \!\!\prec\!  { \tau_{opt} }}{}{}{}{\ljcom{well-formed value}}\ljprodnewline
\ljprodline{|}{\ljnt{P}  \!,  \Gamma  \!,  \ljnt{H}  \vdash  \ljnt{L}}{}{}{}{\ljcom{well-formed variable state}}\ljprodnewline
\ljprodline{|}{\ljnt{P}  \vdash  \ljnt{H}}{}{}{}{\ljcom{well-formed heap}}\ljprodnewline
\ljprodline{|}{\Gamma  \vdash  \ljnt{config}}{}{}{}{\ljcom{well-formed configuration}}\ljprodnewline
\ljprodline{|}{\ljnt{P}  \!,  \Gamma  \vdash  \ljnt{s}}{}{}{}{\ljcom{well-formed statement}}\ljprodnewline
\ljprodline{|}{ \ljnt{P} \vdash _{ \tau }  \ljnt{meth\_def} }{}{}{}{\ljcom{well-formedness of method in $\tau$}}\ljprodnewline
\ljprodline{|}{ \ljnt{P} \vdash _{ \ljnt{ctx} }( \ljmv{dcl} , \ljnt{cl} , \overline{fd} , \overline{meth\_def} ) }{}{}{}{\ljcom{common well-formedness of class in $\ljnt{ctx}$}}\ljprodnewline
\ljprodline{|}{\ljnt{P}  \vdash  \ljnt{cld}}{}{}{}{\ljcom{well-formed class}}\ljprodnewline
\ljprodline{|}{\vdash  \ljnt{P}}{}{}{}{\ljcom{well-formed program}}}

\newcommand{\ljvarXXtrans}{
\ljrulehead{\ljnt{var\_trans}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\theta  \vdash  \ljnt{s}  \leadsto  \ljnt{s'}}{}{}{}{\ljcom{variable translation for a statement}}}

\newcommand{\ljreduction}{
\ljrulehead{\ljnt{reduction}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljnt{config}  \longrightarrow  \ljnt{config'}}{}{}{}{\ljcom{one step reduction}}}

\newcommand{\ljjudgement}{
\ljrulehead{\ljnt{judgement}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljnt{classname\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{superclass\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{classfields\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{classmethods\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{methodname\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{distinct\_names\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{find\_cld\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{find\_type\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{find\_path\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{find\_path\_ty\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{fields\_in\_path\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{fields\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{methods\_in\_path\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{methods\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{ftype\_in\_fds\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{ftype\_in\_path\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{ftype\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{find\_meth\_def\_in\_list\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{find\_meth\_def\_in\_path\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{find\_meth\_def\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{mtype\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{sty\_one\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{sty\_many\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{sty\_option\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{well\_formedness}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{var\_trans}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{reduction}}{}{}{}{}}

\newcommand{\ljuserXXsyntax}{
\ljrulehead{\ljnt{user\_syntax}}{::=}{}\ljprodnewline
\ljfirstprodline{|}{\ljmv{j}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljmv{f}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljmv{meth}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljmv{var}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljmv{dcl}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljmv{oid}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{terminals}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{x}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{x}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{cl}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{fd}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{fd}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{f}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{f}_{opt}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{s}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{vd}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{vd}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{meth\_sig}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{meth\_body}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{meth\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{meth\_def}}{}{}{}{}\ljprodnewline
\ljprodline{|}{meth\_def_{opt}}{}{}{}{}\ljprodnewline
\ljprodline{|}{ctxmeth\_def_{opt}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{meth}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{cld}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\tau}{}{}{}{}\ljprodnewline
\ljprodline{|}{{ \tau_{opt} }}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{ctxcld}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{ctxcld}}{}{}{}{}\ljprodnewline
\ljprodline{|}{ctxcld_{opt}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{ctxcld}_{opt}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\overline{\tau}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\pi}{}{}{}{}\ljprodnewline
\ljprodline{|}{\Gamma}{}{}{}{}\ljprodnewline
\ljprodline{|}{\theta}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{v}}{}{}{}{}\ljprodnewline
\ljprodline{|}{{ v_{opt} }}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{L}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{H}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{config}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{Exception}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{fqn}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{cld}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{P}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{ctx}}{}{}{}{}\ljprodnewline
\ljprodline{|}{\ljnt{formula}}{}{}{}{}}

\newcommand{\ljgrammar}{\ljgrammartabular{
\ljterminals\ljinterrule
\ljx\ljinterrule
\ljX\ljinterrule
\ljcl\ljinterrule
\ljfd\ljinterrule
\ljfds\ljinterrule
\ljfs\ljinterrule
\ljfsXXopt\ljinterrule
\ljs\ljinterrule
\ljvd\ljinterrule
\ljvds\ljinterrule
\ljmethXXsig\ljinterrule
\ljmethXXbody\ljinterrule
\ljmethXXdef\ljinterrule
\ljmethXXdefs\ljinterrule
\ljmethXXdefXXopt\ljinterrule
\ljctxmethXXdefXXopt\ljinterrule
\ljmeths\ljinterrule
\ljclds\ljinterrule
\ljty\ljinterrule
\ljtyXXopt\ljinterrule
\ljctxcld\ljinterrule
\ljctxclds\ljinterrule
\ljctxcldXXopt\ljinterrule
\ljctxcldsXXopt\ljinterrule
\ljtys\ljinterrule
\ljmty\ljinterrule
\ljG\ljinterrule
\ljT\ljinterrule
\ljv\ljinterrule
\ljvXXopt\ljinterrule
\ljL\ljinterrule
\ljH\ljinterrule
\ljconfig\ljinterrule
\ljException\ljinterrule
\ljfqn\ljinterrule
\ljcld\ljinterrule
\ljP\ljinterrule
\ljctx\ljinterrule
\ljformula\ljinterrule
\ljclassnameXXdef\ljinterrule
\ljsuperclassXXdef\ljinterrule
\ljclassfieldsXXdef\ljinterrule
\ljclassmethodsXXdef\ljinterrule
\ljmethodnameXXdef\ljinterrule
\ljdistinctXXnamesXXdef\ljinterrule
\ljfindXXcldXXdef\ljinterrule
\ljfindXXtypeXXdef\ljinterrule
\ljfindXXpathXXdef\ljinterrule
\ljfindXXpathXXtyXXdef\ljinterrule
\ljfieldsXXinXXpathXXdef\ljinterrule
\ljfieldsXXdef\ljinterrule
\ljmethodsXXinXXpathXXdef\ljinterrule
\ljmethodsXXdef\ljinterrule
\ljftypeXXinXXfdsXXdef\ljinterrule
\ljftypeXXinXXpathXXdef\ljinterrule
\ljftypeXXdef\ljinterrule
\ljfindXXmethXXdefXXinXXlistXXdef\ljinterrule
\ljfindXXmethXXdefXXinXXpathXXdef\ljinterrule
\ljfindXXmethXXdefXXdef\ljinterrule
\ljmtypeXXdef\ljinterrule
\ljstyXXoneXXdef\ljinterrule
\ljstyXXmanyXXdef\ljinterrule
\ljstyXXoptionXXdef\ljinterrule
\ljwellXXformedness\ljinterrule
\ljvarXXtrans\ljinterrule
\ljreduction\ljinterrule
\ljjudgement\ljinterrule
\ljuserXXsyntax\ljafterlastrule
}}

% defnss
% defns classname_def
%% defn classname
\newcommand{\ljdruleclassnameName}[0]{\ljdrulename{classname}}
\newcommand{\ljdruleclassname}[1]{\ljdrule[#1]{%
}{
\ljkw{classname} \, (\!  \ljkw{class} \, \ljmv{dcl} \, \ljkw{extends} \, \ljnt{cl}  \ljsym{\{}  \overline{fd} \, \overline{meth\_def}  \ljsym{\}}  \!)  \!=\!  \ljmv{dcl}}{%
{\ljdruleclassnameName}{}%
}}

\newcommand{\ljdefnclassname}[1]{\begin{ljdefnblock}[#1]{$\ljkw{classname} \, (\!  \ljnt{cld}  \!)  \!=\!  \ljmv{dcl}$}{\ljcom{get name of class}}
\ljusedrule{\ljdruleclassname{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsclassnameXXdef}{
\ljdefnclassname{}}

% defns superclass_def
%% defn superclass
\newcommand{\ljdrulesuperclassName}[0]{\ljdrulename{superclass}}
\newcommand{\ljdrulesuperclass}[1]{\ljdrule[#1]{%
}{
\ljkw{superclass} \, (\!  \ljkw{class} \, \ljmv{dcl} \, \ljkw{extends} \, \ljnt{cl}  \ljsym{\{}  \overline{fd} \, \overline{meth\_def}  \ljsym{\}}  \!)  \!=\!  \ljnt{cl}}{%
{\ljdrulesuperclassName}{}%
}}

\newcommand{\ljdefnsuperclass}[1]{\begin{ljdefnblock}[#1]{$\ljkw{superclass} \, (\!  \ljnt{cld}  \!)  \!=\!  \ljnt{cl}$}{\ljcom{get name of superclass}}
\ljusedrule{\ljdrulesuperclass{}}
\end{ljdefnblock}}


\newcommand{\ljdefnssuperclassXXdef}{
\ljdefnsuperclass{}}

% defns classfields_def
%% defn classfields
\newcommand{\ljdruleclassfieldsName}[0]{\ljdrulename{classfields}}
\newcommand{\ljdruleclassfields}[1]{\ljdrule[#1]{%
}{
\ljkw{classfields} \, (\!  \ljkw{class} \, \ljmv{dcl} \, \ljkw{extends} \, \ljnt{cl}  \ljsym{\{}  \overline{fd} \, \overline{meth\_def}  \ljsym{\}}  \!)  \!=\!  \overline{fd}}{%
{\ljdruleclassfieldsName}{}%
}}

\newcommand{\ljdefnclassfields}[1]{\begin{ljdefnblock}[#1]{$\ljkw{classfields} \, (\!  \ljnt{cld}  \!)  \!=\!  \overline{fd}$}{\ljcom{get class fields}}
\ljusedrule{\ljdruleclassfields{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsclassfieldsXXdef}{
\ljdefnclassfields{}}

% defns classmethods_def
%% defn classmethods
\newcommand{\ljdruleclassmethodsName}[0]{\ljdrulename{classmethods}}
\newcommand{\ljdruleclassmethods}[1]{\ljdrule[#1]{%
}{
\ljkw{classmethods} \, (\!  \ljkw{class} \, \ljmv{dcl} \, \ljkw{extends} \, \ljnt{cl}  \ljsym{\{}  \overline{fd} \, \overline{meth\_def}  \ljsym{\}}  \!)  \!=\!  \overline{meth\_def}}{%
{\ljdruleclassmethodsName}{}%
}}

\newcommand{\ljdefnclassmethods}[1]{\begin{ljdefnblock}[#1]{$\ljkw{classmethods} \, (\!  \ljnt{cld}  \!)  \!=\!  \overline{meth\_def}$}{\ljcom{get class methods}}
\ljusedrule{\ljdruleclassmethods{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsclassmethodsXXdef}{
\ljdefnclassmethods{}}

% defns methodname_def
%% defn methodname
\newcommand{\ljdrulemethodnameName}[0]{\ljdrulename{methodname}}
\newcommand{\ljdrulemethodname}[1]{\ljdrule[#1]{%
}{
\ljkw{methodname} \, (\!  \ljnt{cl} \, \ljmv{meth}  (\!  \overline{vd}  \!)  \ljsym{\{}  \ljnt{meth\_body}  \ljsym{\}}  \!)  \!=\!  \ljmv{meth}}{%
{\ljdrulemethodnameName}{}%
}}

\newcommand{\ljdefnmethodname}[1]{\begin{ljdefnblock}[#1]{$\ljkw{methodname} \, (\!  \ljnt{meth\_def}  \!)  \!=\!  \ljmv{meth}$}{\ljcom{get method's name}}
\ljusedrule{\ljdrulemethodname{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsmethodnameXXdef}{
\ljdefnmethodname{}}

% defns distinct_names_def
%% defn distinct_names
\newcommand{\ljdrulednXXdefName}[0]{\ljdrulename{dn\_def}}
\newcommand{\ljdrulednXXdef}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{P}  \!=\!  \ljcomp{\ljnt{cld_{\ljmv{k}}}}{\ljmv{k}}}%
\ljpremise{\ljcomp{\ljkw{classname} \, (\!  \ljnt{cld_{\ljmv{k}}}  \!)  \!=\!  \ljmv{dcl_{\ljmv{k}}}}{\ljmv{k}}}%
\ljpremise{\ljkw{distinct} \, (\! \, \ljcomp{\ljmv{dcl_{\ljmv{k}}}}{\ljmv{k}} \, \!)}%
}{
\ljsym{distinct\_names}  (\!  \ljnt{P}  \!)}{%
{\ljdrulednXXdefName}{}%
}}

\newcommand{\ljdefndistinctXXnames}[1]{\begin{ljdefnblock}[#1]{$\ljsym{distinct\_names}  (\!  \ljnt{P}  \!)$}{\ljcom{distinct names of type definitions}}
\ljusedrule{\ljdrulednXXdef{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsdistinctXXnamesXXdef}{
\ljdefndistinctXXnames{}}

% defns find_cld_def
%% defn find_cld
\newcommand{\ljdrulefcXXemptyName}[0]{\ljdrulename{fc\_empty}}
\newcommand{\ljdrulefcXXempty}[1]{\ljdrule[#1]{%
}{
\ljsym{find\_cld}  (\!  \,  \!,  \ljnt{ctx}  \!,  \ljnt{fqn}  \!)  \!=\!  \ljkw{null}}{%
{\ljdrulefcXXemptyName}{}%
}}


\newcommand{\ljdrulefcXXconsXXtrueName}[0]{\ljdrulename{fc\_cons\_true}}
\newcommand{\ljdrulefcXXconsXXtrue}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{P}  \!=\!  \ljnt{cld} \, \ljnt{cld_{{\mathrm{2}}}} \, .. \, \ljnt{cld_{\ljmv{k}}}}%
\ljpremise{\ljnt{cld}  \!=\!  \ljkw{class} \, \ljmv{dcl} \, \ljkw{extends} \, \ljnt{cl}  \ljsym{\{}  \overline{fd} \, \overline{meth\_def}  \ljsym{\}}}%
}{
\ljsym{find\_cld}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljmv{dcl}  \!)  \!=\!  (\!  \ljnt{ctx}  \!,  \ljnt{cld}  \!)}{%
{\ljdrulefcXXconsXXtrueName}{}%
}}


\newcommand{\ljdrulefcXXconsXXfalseName}[0]{\ljdrulename{fc\_cons\_false}}
\newcommand{\ljdrulefcXXconsXXfalse}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{cld}  \!=\!  \ljkw{class} \, \ljmv{dcl'} \, \ljkw{extends} \, \ljnt{cl}  \ljsym{\{}  \overline{fd} \, \overline{meth\_def}  \ljsym{\}}}%
\ljpremise{\ljmv{dcl}  \neq  \ljmv{dcl'}}%
\ljpremise{\ljsym{find\_cld}  (\!  \ljnt{cld_{{\mathrm{2}}}} \, .. \, \ljnt{cld_{\ljmv{k}}}  \!,  \ljnt{ctx}  \!,  \ljmv{dcl}  \!)  \!=\!  ctxcld_{opt}}%
}{
\ljsym{find\_cld}  (\!  \ljnt{cld} \, \ljnt{cld_{{\mathrm{2}}}} \, .. \, \ljnt{cld_{\ljmv{k}}}  \!,  \ljnt{ctx}  \!,  \ljmv{dcl}  \!)  \!=\!  ctxcld_{opt}}{%
{\ljdrulefcXXconsXXfalseName}{}%
}}

\newcommand{\ljdefnfindXXcld}[1]{\begin{ljdefnblock}[#1]{$\ljsym{find\_cld}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{fqn}  \!)  \!=\!  ctxcld_{opt}$}{\ljcom{class def.~lookup}}
\ljusedrule{\ljdrulefcXXempty{}}
\ljusedrule{\ljdrulefcXXconsXXtrue{}}
\ljusedrule{\ljdrulefcXXconsXXfalse{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsfindXXcldXXdef}{
\ljdefnfindXXcld{}}

% defns find_type_def
%% defn find_type
\newcommand{\ljdruleftXXobjName}[0]{\ljdrulename{ft\_obj}}
\newcommand{\ljdruleftXXobj}[1]{\ljdrule[#1]{%
}{
\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljkw{Object}  \!)  \!=\!  \ljkw{Object}}{%
{\ljdruleftXXobjName}{}%
}}


\newcommand{\ljdruleftXXnullName}[0]{\ljdrulename{ft\_null}}
\newcommand{\ljdruleftXXnull}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_cld}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljmv{dcl}  \!)  \!=\!  \ljkw{null}}%
}{
\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljmv{dcl}  \!)  \!=\!  \ljkw{null}}{%
{\ljdruleftXXnullName}{}%
}}


\newcommand{\ljdruleftXXdclName}[0]{\ljdrulename{ft\_dcl}}
\newcommand{\ljdruleftXXdcl}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_cld}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljmv{dcl}  \!)  \!=\!  (\!  \ljnt{ctx'}  \!,  \ljnt{cld}  \!)}%
}{
\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljmv{dcl}  \!)  \!=\!   \ljnt{ctx'} \hspace{-.1ex}.\hspace{-.1ex} \ljmv{dcl} }{%
{\ljdruleftXXdclName}{}%
}}

\newcommand{\ljdefnfindXXtype}[1]{\begin{ljdefnblock}[#1]{$\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl}  \!)  \!=\!  { \tau_{opt} }$}{\ljcom{type lookup}}
\ljusedrule{\ljdruleftXXobj{}}
\ljusedrule{\ljdruleftXXnull{}}
\ljusedrule{\ljdruleftXXdcl{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsfindXXtypeXXdef}{
\ljdefnfindXXtype{}}

% defns find_path_def
%% defn find_path
\newcommand{\ljdrulefpclXXobjName}[0]{\ljdrulename{fpcl\_obj}}
\newcommand{\ljdrulefpclXXobj}[1]{\ljdrule[#1]{%
}{
\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljkw{Object}  \!)  \!=\!  \,}{%
{\ljdrulefpclXXobjName}{}%
}}


\newcommand{\ljdrulefpclXXdistinctName}[0]{\ljdrulename{fpcl\_distinct}}
\newcommand{\ljdrulefpclXXdistinct}[1]{\ljdrule[#1]{%
\ljpremise{\texttt{\textcolor{red}{<<multiple parses>>}}}%
}{
\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{fqn}  \!)  \!=\!  \ljkw{null}}{%
{\ljdrulefpclXXdistinctName}{}%
}}


\newcommand{\ljdrulefpclXXhdXXnullName}[0]{\ljdrulename{fpcl\_hd\_null}}
\newcommand{\ljdrulefpclXXhdXXnull}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_cld}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{fqn}  \!)  \!=\!  \ljkw{null}}%
}{
\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{fqn}  \!)  \!=\!  \ljkw{null}}{%
{\ljdrulefpclXXhdXXnullName}{}%
}}


\newcommand{\ljdrulefpclXXtlXXnullName}[0]{\ljdrulename{fpcl\_tl\_null}}
\newcommand{\ljdrulefpclXXtlXXnull}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_cld}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{fqn}  \!)  \!=\!  (\!  \ljnt{ctx'}  \!,  \ljnt{cld}  \!)}%
\ljpremise{\ljkw{superclass} \, (\!  \ljnt{cld}  \!)  \!=\!  \ljnt{cl}}%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctx'}  \!,  \ljnt{cl}  \!)  \!=\!  \ljkw{null}}%
}{
\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{fqn}  \!)  \!=\!  \ljkw{null}}{%
{\ljdrulefpclXXtlXXnullName}{}%
}}


\newcommand{\ljdrulefpclXXdclName}[0]{\ljdrulename{fpcl\_dcl}}
\newcommand{\ljdrulefpclXXdcl}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_cld}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{fqn}  \!)  \!=\!  (\!  \ljnt{ctx'}  \!,  \ljnt{cld}  \!)}%
\ljpremise{\ljkw{superclass} \, (\!  \ljnt{cld}  \!)  \!=\!  \ljnt{cl}}%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctx'}  \!,  \ljnt{cl}  \!)  \!=\!  \ljcomp{(\!  \ljnt{ctx_{\ljmv{k}}}  \!,  \ljnt{cld_{\ljmv{k}}}  \!)}{\ljmv{k}}}%
\ljpremise{\overline{ctxcld}  \!=\!  (\!  \ljnt{ctx'}  \!,  \ljnt{cld}  \!) \, \ljcomp{(\!  \ljnt{ctx_{\ljmv{k}}}  \!,  \ljnt{cld_{\ljmv{k}}}  \!)}{\ljmv{k}}}%
\ljpremise{\ljsym{distinct\_names}  (\!  \ljnt{P}  \!)}%
}{
\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{fqn}  \!)  \!=\!  \overline{ctxcld}}{%
{\ljdrulefpclXXdclName}{}%
}}

\newcommand{\ljdefnfindXXpath}[1]{\begin{ljdefnblock}[#1]{$\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl}  \!)  \!=\!  \overline{ctxcld}_{opt}$}{\ljcom{find class hierarchy path}}
\ljusedrule{\ljdrulefpclXXobj{}}
\ljusedrule{\ljdrulefpclXXdistinct{}}
\ljusedrule{\ljdrulefpclXXhdXXnull{}}
\ljusedrule{\ljdrulefpclXXtlXXnull{}}
\ljusedrule{\ljdrulefpclXXdcl{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsfindXXpathXXdef}{
\ljdefnfindXXpath{}}

% defns find_path_ty_def
%% defn find_path_ty
\newcommand{\ljdrulefptyXXobjName}[0]{\ljdrulename{fpty\_obj}}
\newcommand{\ljdrulefptyXXobj}[1]{\ljdrule[#1]{%
}{
\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljkw{Object}  \!)  \!=\!  \,}{%
{\ljdrulefptyXXobjName}{}%
}}


\newcommand{\ljdrulefptyXXdclName}[0]{\ljdrulename{fpty\_dcl}}
\newcommand{\ljdrulefptyXXdcl}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljmv{dcl}  \!)  \!=\!  \overline{ctxcld}_{opt}}%
}{
\ljsym{find\_path}  (\!  \ljnt{P}  \!,   \ljnt{ctx} \hspace{-.1ex}.\hspace{-.1ex} \ljmv{dcl}   \!)  \!=\!  \overline{ctxcld}_{opt}}{%
{\ljdrulefptyXXdclName}{}%
}}

\newcommand{\ljdefnfindXXpathXXty}[1]{\begin{ljdefnblock}[#1]{$\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{ctxcld}_{opt}$}{\ljcom{find class hierarchy path}}
\ljusedrule{\ljdrulefptyXXobj{}}
\ljusedrule{\ljdrulefptyXXdcl{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsfindXXpathXXtyXXdef}{
\ljdefnfindXXpathXXty{}}

% defns fields_in_path_def
%% defn fields_in_path
\newcommand{\ljdrulefipXXemptyName}[0]{\ljdrulename{fip\_empty}}
\newcommand{\ljdrulefipXXempty}[1]{\ljdrule[#1]{%
}{
\ljsym{fields\_in\_path}  (\!  \,  \!)  \!=\!  \,}{%
{\ljdrulefipXXemptyName}{}%
}}


\newcommand{\ljdrulefipXXconsName}[0]{\ljdrulename{fip\_cons}}
\newcommand{\ljdrulefipXXcons}[1]{\ljdrule[#1]{%
\ljpremise{\overline{cld}  \!=\!  \ljnt{cld} \, \ljnt{cld_{{\mathrm{2}}}} \, .. \, \ljnt{cld_{\ljmv{k}}}}%
\ljpremise{\ljkw{classfields} \, (\!  \ljnt{cld}  \!)  \!=\!  \ljcomp{\ljnt{cl_{\ljmv{j}}} \, \ljmv{f_{\ljmv{j}}}  \ljsym{;}}{\ljmv{j}}}%
\ljpremise{\ljsym{fields\_in\_path}  (\!  \ljnt{cld_{{\mathrm{2}}}} \, .. \, \ljnt{cld_{\ljmv{k}}}  \!)  \!=\!  \overline{f}}%
\ljpremise{\overline{f}'  \!=\!  \ljcomp{\ljmv{f_{\ljmv{j}}}}{\ljmv{j}}  \ljsym{;}  \overline{f}}%
}{
\ljsym{fields\_in\_path}  (\!  \overline{cld}  \!)  \!=\!  \overline{f}'}{%
{\ljdrulefipXXconsName}{}%
}}

\newcommand{\ljdefnfieldsXXinXXpath}[1]{\begin{ljdefnblock}[#1]{$\ljsym{fields\_in\_path}  (\!  \overline{cld}  \!)  \!=\!  \overline{f}$}{\ljcom{get fields in class path}}
\ljusedrule{\ljdrulefipXXempty{}}
\ljusedrule{\ljdrulefipXXcons{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsfieldsXXinXXpathXXdef}{
\ljdefnfieldsXXinXXpath{}}

% defns fields_def
%% defn fields
\newcommand{\ljdrulefieldsXXnullName}[0]{\ljdrulename{fields\_null}}
\newcommand{\ljdrulefieldsXXnull}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \ljkw{null}}%
}{
\ljkw{fields} \, (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \ljkw{null}}{%
{\ljdrulefieldsXXnullName}{}%
}}


\newcommand{\ljdrulefieldsXXsomeName}[0]{\ljdrulename{fields\_some}}
\newcommand{\ljdrulefieldsXXsome}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \ljcomp{(\!  \ljnt{ctx_{\ljmv{k}}}  \!,  \ljnt{cld_{\ljmv{k}}}  \!)}{\ljmv{k}}}%
\ljpremise{\ljsym{fields\_in\_path}  (\!  \ljcomp{\ljnt{cld_{\ljmv{k}}}}{\ljmv{k}}  \!)  \!=\!  \overline{f}}%
}{
\ljkw{fields} \, (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{f}}{%
{\ljdrulefieldsXXsomeName}{}%
}}

\newcommand{\ljdefnfields}[1]{\begin{ljdefnblock}[#1]{$\ljkw{fields} \, (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{f}_{opt}$}{\ljcom{get all fields of $\tau$}}
\ljusedrule{\ljdrulefieldsXXnull{}}
\ljusedrule{\ljdrulefieldsXXsome{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsfieldsXXdef}{
\ljdefnfields{}}

% defns methods_in_path_def
%% defn methods_in_path
\newcommand{\ljdrulemipXXemptyName}[0]{\ljdrulename{mip\_empty}}
\newcommand{\ljdrulemipXXempty}[1]{\ljdrule[#1]{%
}{
\ljsym{methods\_in\_path}  (\!  \,  \!)  \!=\!  \,}{%
{\ljdrulemipXXemptyName}{}%
}}


\newcommand{\ljdrulemipXXconsName}[0]{\ljdrulename{mip\_cons}}
\newcommand{\ljdrulemipXXcons}[1]{\ljdrule[#1]{%
\ljpremise{\ljkw{classmethods} \, (\!  \ljnt{cld}  \!)  \!=\!  \ljcomp{\ljnt{meth\_def_{\ljmv{l}}}}{\ljmv{l}}}%
\ljpremise{\ljcomp{\ljnt{meth\_def_{\ljmv{l}}}  \!=\!  \ljnt{cl_{\ljmv{l}}} \, \ljmv{meth_{\ljmv{l}}}  (\!  \overline{vd}_{\ljmv{l}}  \!)  \ljsym{\{}  \ljnt{meth\_body_{\ljmv{l}}}  \ljsym{\}}}{\ljmv{l}}}%
\ljpremise{\ljsym{methods\_in\_path}  (\!  \ljnt{cld_{{\mathrm{2}}}} \, .. \, \ljnt{cld_{\ljmv{k}}}  \!)  \!=\!  \overline{meth}'}%
\ljpremise{\overline{meth}  \!=\!  \ljcomp{\ljmv{meth_{\ljmv{l}}}}{\ljmv{l}}  \ljsym{;}  \overline{meth}'}%
}{
\ljsym{methods\_in\_path}  (\!  \ljnt{cld} \, \ljnt{cld_{{\mathrm{2}}}} \, .. \, \ljnt{cld_{\ljmv{k}}}  \!)  \!=\!  \overline{meth}}{%
{\ljdrulemipXXconsName}{}%
}}

\newcommand{\ljdefnmethodsXXinXXpath}[1]{\begin{ljdefnblock}[#1]{$\ljsym{methods\_in\_path}  (\!  \overline{cld}  \!)  \!=\!  \overline{meth}$}{\ljcom{get all method names in class path}}
\ljusedrule{\ljdrulemipXXempty{}}
\ljusedrule{\ljdrulemipXXcons{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsmethodsXXinXXpathXXdef}{
\ljdefnmethodsXXinXXpath{}}

% defns methods_def
%% defn methods
\newcommand{\ljdrulemethodsXXmethodsName}[0]{\ljdrulename{methods\_methods}}
\newcommand{\ljdrulemethodsXXmethods}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \ljcomp{(\!  \ljnt{ctx_{\ljmv{k}}}  \!,  \ljnt{cld_{\ljmv{k}}}  \!)}{\ljmv{k}}}%
\ljpremise{\ljsym{methods\_in\_path}  (\!  \ljcomp{\ljnt{cld_{\ljmv{k}}}}{\ljmv{k}}  \!)  \!=\!  \overline{meth}}%
}{
\ljkw{methods} \, (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{meth}}{%
{\ljdrulemethodsXXmethodsName}{}%
}}

\newcommand{\ljdefnmethods}[1]{\begin{ljdefnblock}[#1]{$\ljkw{methods} \, (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{meth}$}{\ljcom{get all method names of $\tau$}}
\ljusedrule{\ljdrulemethodsXXmethods{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsmethodsXXdef}{
\ljdefnmethods{}}

% defns ftype_in_fds_def
%% defn ftype_in_fds
\newcommand{\ljdruleftifXXemptyName}[0]{\ljdrulename{ftif\_empty}}
\newcommand{\ljdruleftifXXempty}[1]{\ljdrule[#1]{%
}{
\ljsym{ftype\_in\_fds}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \,  \!,  \ljmv{f}  \!)  \!=\!  \ljkw{null}}{%
{\ljdruleftifXXemptyName}{}%
}}


\newcommand{\ljdruleftifXXconsXXtrueName}[0]{\ljdrulename{ftif\_cons\_true}}
\newcommand{\ljdruleftifXXconsXXtrue}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl}  \!)  \!=\!  { \tau_{opt} }}%
}{
\ljsym{ftype\_in\_fds}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl} \, \ljmv{f}  \ljsym{;} \, \ljnt{fd_{{\mathrm{2}}}} \, .. \, \ljnt{fd_{\ljmv{k}}}  \!,  \ljmv{f}  \!)  \!=\!  { \tau_{opt} }}{%
{\ljdruleftifXXconsXXtrueName}{}%
}}


\newcommand{\ljdruleftifXXconsXXfalseName}[0]{\ljdrulename{ftif\_cons\_false}}
\newcommand{\ljdruleftifXXconsXXfalse}[1]{\ljdrule[#1]{%
\ljpremise{\ljmv{f}  \neq  \ljmv{f'}}%
\ljpremise{\ljsym{ftype\_in\_fds}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{fd_{{\mathrm{2}}}} \, .. \, \ljnt{fd_{\ljmv{k}}}  \!,  \ljmv{f'}  \!)  \!=\!  { \tau_{opt} }}%
}{
\ljsym{ftype\_in\_fds}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl} \, \ljmv{f}  \ljsym{;} \, \ljnt{fd_{{\mathrm{2}}}} \, .. \, \ljnt{fd_{\ljmv{k}}}  \!,  \ljmv{f'}  \!)  \!=\!  { \tau_{opt} }}{%
{\ljdruleftifXXconsXXfalseName}{}%
}}

\newcommand{\ljdefnftypeXXinXXfds}[1]{\begin{ljdefnblock}[#1]{$\ljsym{ftype\_in\_fds}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \overline{fd}  \!,  \ljmv{f}  \!)  \!=\!  { \tau_{opt} }$}{\ljcom{get class of $\ljmv{f}$ from field declarations}}
\ljusedrule{\ljdruleftifXXempty{}}
\ljusedrule{\ljdruleftifXXconsXXtrue{}}
\ljusedrule{\ljdruleftifXXconsXXfalse{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsftypeXXinXXfdsXXdef}{
\ljdefnftypeXXinXXfds{}}

% defns ftype_in_path_def
%% defn ftype_in_path
\newcommand{\ljdruleftipXXemptyName}[0]{\ljdrulename{ftip\_empty}}
\newcommand{\ljdruleftipXXempty}[1]{\ljdrule[#1]{%
}{
\ljsym{ftype\_in\_path}  (\!  \ljnt{P}  \!,  \,  \!,  \ljmv{f}  \!)  \!=\!  \ljkw{null}}{%
{\ljdruleftipXXemptyName}{}%
}}


\newcommand{\ljdruleftipXXconsXXtrueName}[0]{\ljdrulename{ftip\_cons\_true}}
\newcommand{\ljdruleftipXXconsXXtrue}[1]{\ljdrule[#1]{%
\ljpremise{\ljkw{classfields} \, (\!  \ljnt{cld}  \!)  \!=\!  \overline{fd}}%
\ljpremise{\ljsym{ftype\_in\_fds}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \overline{fd}  \!,  \ljmv{f}  \!)  \!=\!  \tau}%
}{
\ljsym{ftype\_in\_path}  (\!  \ljnt{P}  \!,  (\!  \ljnt{ctx}  \!,  \ljnt{cld}  \!) \, \ljnt{ctxcld_{{\mathrm{2}}}} \, .. \, \ljnt{ctxcld_{\ljmv{k}}}  \!,  \ljmv{f}  \!)  \!=\!  \tau}{%
{\ljdruleftipXXconsXXtrueName}{}%
}}


\newcommand{\ljdruleftipXXconsXXfalseName}[0]{\ljdrulename{ftip\_cons\_false}}
\newcommand{\ljdruleftipXXconsXXfalse}[1]{\ljdrule[#1]{%
\ljpremise{\ljkw{classfields} \, (\!  \ljnt{cld}  \!)  \!=\!  \overline{fd}}%
\ljpremise{\ljsym{ftype\_in\_fds}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \overline{fd}  \!,  \ljmv{f}  \!)  \!=\!  \ljkw{null}}%
\ljpremise{\ljsym{ftype\_in\_path}  (\!  \ljnt{P}  \!,  \ljnt{ctxcld_{{\mathrm{2}}}} \, .. \, \ljnt{ctxcld_{\ljmv{k}}}  \!,  \ljmv{f}  \!)  \!=\!  { \tau_{opt} }}%
}{
\ljsym{ftype\_in\_path}  (\!  \ljnt{P}  \!,  (\!  \ljnt{ctx}  \!,  \ljnt{cld}  \!) \, \ljnt{ctxcld_{{\mathrm{2}}}} \, .. \, \ljnt{ctxcld_{\ljmv{k}}}  \!,  \ljmv{f}  \!)  \!=\!  { \tau_{opt} }}{%
{\ljdruleftipXXconsXXfalseName}{}%
}}

\newcommand{\ljdefnftypeXXinXXpath}[1]{\begin{ljdefnblock}[#1]{$\ljsym{ftype\_in\_path}  (\!  \ljnt{P}  \!,  \overline{ctxcld}  \!,  \ljmv{f}  \!)  \!=\!  { \tau_{opt} }$}{\ljcom{get type of $\ljmv{f}$ in class path}}
\ljusedrule{\ljdruleftipXXempty{}}
\ljusedrule{\ljdruleftipXXconsXXtrue{}}
\ljusedrule{\ljdruleftipXXconsXXfalse{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsftypeXXinXXpathXXdef}{
\ljdefnftypeXXinXXpath{}}

% defns ftype_def
%% defn ftype
\newcommand{\ljdruleftypeName}[0]{\ljdrulename{ftype}}
\newcommand{\ljdruleftype}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{ctxcld}}%
\ljpremise{\ljsym{ftype\_in\_path}  (\!  \ljnt{P}  \!,  \overline{ctxcld}  \!,  \ljmv{f}  \!)  \!=\!  \tau'}%
}{
\ljkw{ftype} \, (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{f}  \!)  \!=\!  \tau'}{%
{\ljdruleftypeName}{}%
}}

\newcommand{\ljdefnftype}[1]{\begin{ljdefnblock}[#1]{$\ljkw{ftype} \, (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{f}  \!)  \!=\!  \tau'$}{\ljcom{get type of $\ljmv{f}$ in $\tau$}}
\ljusedrule{\ljdruleftype{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsftypeXXdef}{
\ljdefnftype{}}

% defns find_meth_def_in_list_def
%% defn find_meth_def_in_list
\newcommand{\ljdrulefmdilXXemptyName}[0]{\ljdrulename{fmdil\_empty}}
\newcommand{\ljdrulefmdilXXempty}[1]{\ljdrule[#1]{%
}{
\ljsym{find\_meth\_def\_in\_list}  (\!  \,  \!,  \ljmv{meth}  \!)  \!=\!  \ljkw{null}}{%
{\ljdrulefmdilXXemptyName}{}%
}}


\newcommand{\ljdrulefmdilXXconsXXtrueName}[0]{\ljdrulename{fmdil\_cons\_true}}
\newcommand{\ljdrulefmdilXXconsXXtrue}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{meth\_def}  \!=\!  \ljnt{cl} \, \ljmv{meth}  (\!  \overline{vd}  \!)  \ljsym{\{}  \ljnt{meth\_body}  \ljsym{\}}}%
}{
\ljsym{find\_meth\_def\_in\_list}  (\!  \ljnt{meth\_def} \, \ljnt{meth\_def_{{\mathrm{2}}}} \, .. \, \ljnt{meth\_def_{\ljmv{k}}}  \!,  \ljmv{meth}  \!)  \!=\!  \ljnt{meth\_def}}{%
{\ljdrulefmdilXXconsXXtrueName}{}%
}}


\newcommand{\ljdrulefmdilXXconsXXfalseName}[0]{\ljdrulename{fmdil\_cons\_false}}
\newcommand{\ljdrulefmdilXXconsXXfalse}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{meth\_def}  \!=\!  \ljnt{cl} \, \ljmv{meth'}  (\!  \overline{vd}  \!)  \ljsym{\{}  \ljnt{meth\_body}  \ljsym{\}}}%
\ljpremise{\ljmv{meth}  \neq  \ljmv{meth'}}%
\ljpremise{\ljsym{find\_meth\_def\_in\_list}  (\!  \ljnt{meth\_def_{{\mathrm{2}}}} \, .. \, \ljnt{meth\_def_{\ljmv{k}}}  \!,  \ljmv{meth}  \!)  \!=\!  meth\_def_{opt}}%
}{
\ljsym{find\_meth\_def\_in\_list}  (\!  \ljnt{meth\_def} \, \ljnt{meth\_def_{{\mathrm{2}}}} \, .. \, \ljnt{meth\_def_{\ljmv{k}}}  \!,  \ljmv{meth}  \!)  \!=\!  meth\_def_{opt}}{%
{\ljdrulefmdilXXconsXXfalseName}{}%
}}

\newcommand{\ljdefnfindXXmethXXdefXXinXXlist}[1]{\begin{ljdefnblock}[#1]{$\ljsym{find\_meth\_def\_in\_list}  (\!  \overline{meth\_def}  \!,  \ljmv{meth}  \!)  \!=\!  meth\_def_{opt}$}{\ljcom{find method def.~in list}}
\ljusedrule{\ljdrulefmdilXXempty{}}
\ljusedrule{\ljdrulefmdilXXconsXXtrue{}}
\ljusedrule{\ljdrulefmdilXXconsXXfalse{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsfindXXmethXXdefXXinXXlistXXdef}{
\ljdefnfindXXmethXXdefXXinXXlist{}}

% defns find_meth_def_in_path_def
%% defn find_meth_def_in_path
\newcommand{\ljdrulefmdipXXemptyName}[0]{\ljdrulename{fmdip\_empty}}
\newcommand{\ljdrulefmdipXXempty}[1]{\ljdrule[#1]{%
}{
\ljsym{find\_meth\_def\_in\_path}  (\!  \,  \!,  \ljmv{meth}  \!)  \!=\!  \ljkw{null}}{%
{\ljdrulefmdipXXemptyName}{}%
}}


\newcommand{\ljdrulefmdipXXconsXXtrueName}[0]{\ljdrulename{fmdip\_cons\_true}}
\newcommand{\ljdrulefmdipXXconsXXtrue}[1]{\ljdrule[#1]{%
\ljpremise{\ljkw{classmethods} \, (\!  \ljnt{cld}  \!)  \!=\!  \overline{meth\_def}}%
\ljpremise{\ljsym{find\_meth\_def\_in\_list}  (\!  \overline{meth\_def}  \!,  \ljmv{meth}  \!)  \!=\!  \ljnt{meth\_def}}%
}{
\ljsym{find\_meth\_def\_in\_path}  (\!  (\!  \ljnt{ctx}  \!,  \ljnt{cld}  \!) \, \ljnt{ctxcld_{{\mathrm{2}}}} \, .. \, \ljnt{ctxcld_{\ljmv{k}}}  \!,  \ljmv{meth}  \!)  \!=\!  (\!  \ljnt{ctx}  \!,  \ljnt{meth\_def}  \!)}{%
{\ljdrulefmdipXXconsXXtrueName}{}%
}}


\newcommand{\ljdrulefmdipXXconsXXfalseName}[0]{\ljdrulename{fmdip\_cons\_false}}
\newcommand{\ljdrulefmdipXXconsXXfalse}[1]{\ljdrule[#1]{%
\ljpremise{\ljkw{classmethods} \, (\!  \ljnt{cld}  \!)  \!=\!  \overline{meth\_def}}%
\ljpremise{\ljsym{find\_meth\_def\_in\_list}  (\!  \overline{meth\_def}  \!,  \ljmv{meth}  \!)  \!=\!  \ljkw{null}}%
\ljpremise{\ljsym{find\_meth\_def\_in\_path}  (\!  \ljnt{ctxcld_{{\mathrm{2}}}} \, .. \, \ljnt{ctxcld_{\ljmv{k}}}  \!,  \ljmv{meth}  \!)  \!=\!  ctxmeth\_def_{opt}}%
}{
\ljsym{find\_meth\_def\_in\_path}  (\!  (\!  \ljnt{ctx}  \!,  \ljnt{cld}  \!) \, \ljnt{ctxcld_{{\mathrm{2}}}} \, .. \, \ljnt{ctxcld_{\ljmv{k}}}  \!,  \ljmv{meth}  \!)  \!=\!  ctxmeth\_def_{opt}}{%
{\ljdrulefmdipXXconsXXfalseName}{}%
}}

\newcommand{\ljdefnfindXXmethXXdefXXinXXpath}[1]{\begin{ljdefnblock}[#1]{$\ljsym{find\_meth\_def\_in\_path}  (\!  \overline{ctxcld}  \!,  \ljmv{meth}  \!)  \!=\!  ctxmeth\_def_{opt}$}{\ljcom{find method def.~(and context) in class path}}
\ljusedrule{\ljdrulefmdipXXempty{}}
\ljusedrule{\ljdrulefmdipXXconsXXtrue{}}
\ljusedrule{\ljdrulefmdipXXconsXXfalse{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsfindXXmethXXdefXXinXXpathXXdef}{
\ljdefnfindXXmethXXdefXXinXXpath{}}

% defns find_meth_def_def
%% defn find_meth_def
\newcommand{\ljdrulefmdXXnullName}[0]{\ljdrulename{fmd\_null}}
\newcommand{\ljdrulefmdXXnull}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \ljkw{null}}%
}{
\ljsym{find\_meth\_def}  (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  \ljkw{null}}{%
{\ljdrulefmdXXnullName}{}%
}}


\newcommand{\ljdrulefmdXXoptName}[0]{\ljdrulename{fmd\_opt}}
\newcommand{\ljdrulefmdXXopt}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{ctxcld}}%
\ljpremise{\ljsym{find\_meth\_def\_in\_path}  (\!  \overline{ctxcld}  \!,  \ljmv{meth}  \!)  \!=\!  ctxmeth\_def_{opt}}%
}{
\ljsym{find\_meth\_def}  (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  ctxmeth\_def_{opt}}{%
{\ljdrulefmdXXoptName}{}%
}}

\newcommand{\ljdefnfindXXmethXXdef}[1]{\begin{ljdefnblock}[#1]{$\ljsym{find\_meth\_def}  (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  ctxmeth\_def_{opt}$}{\ljcom{find method def.~(given dynamic type $\tau$)}}
\ljusedrule{\ljdrulefmdXXnull{}}
\ljusedrule{\ljdrulefmdXXopt{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsfindXXmethXXdefXXdef}{
\ljdefnfindXXmethXXdef{}}

% defns mtype_def
%% defn mtype
\newcommand{\ljdrulemtypeName}[0]{\ljdrulename{mtype}}
\newcommand{\ljdrulemtype}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_meth\_def}  (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  (\!  \ljnt{ctx}  \!,  \ljnt{meth\_def}  \!)}%
\ljpremise{\ljnt{meth\_def}  \!=\!  \ljnt{cl} \, \ljmv{meth}  (\!  \ljcomp{\ljnt{cl_{\ljmv{k}}} \, \ljmv{var_{\ljmv{k}}}}{\ljmv{k}}  \!)  \ljsym{\{}  \ljnt{meth\_body}  \ljsym{\}}}%
\ljpremise{\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl}  \!)  \!=\!  \tau'}%
\ljpremise{\ljcomp{\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl_{\ljmv{k}}}  \!)  \!=\!  \tau_{\ljmv{k}}}{\ljmv{k}}}%
\ljpremise{\pi  \!=\!  \ljcomp{\tau_{\ljmv{k}}}{\ljmv{k}}  \rightarrow  \tau'}%
}{
\ljkw{mtype} \, (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  \pi}{%
{\ljdrulemtypeName}{}%
}}

\newcommand{\ljdefnmtype}[1]{\begin{ljdefnblock}[#1]{$\ljkw{mtype} \, (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  \pi$}{\ljcom{find method type}}
\ljusedrule{\ljdrulemtype{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsmtypeXXdef}{
\ljdefnmtype{}}

% defns sty_one_def
%% defn one
\newcommand{\ljdrulestyXXobjName}[0]{\ljdrulename{sty\_obj}}
\newcommand{\ljdrulestyXXobj}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{ctxcld}}%
}{
\ljnt{P}  \vdash  \tau  \!\!\prec\!  \ljkw{Object}}{%
{\ljdrulestyXXobjName}{}%
}}


\newcommand{\ljdrulestyXXdclName}[0]{\ljdrulename{sty\_dcl}}
\newcommand{\ljdrulestyXXdcl}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_path}  (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \ljcomp{(\!  \ljnt{ctx_{\ljmv{k}}}  \!,  \ljnt{cld_{\ljmv{k}}}  \!)}{\ljmv{k}}}%
\ljpremise{\ljcomp{\ljkw{classname} \, (\!  \ljnt{cld_{\ljmv{k}}}  \!)  \!=\!  \ljmv{dcl_{\ljmv{k}}}}{\ljmv{k}}}%
\ljpremise{(\!  \ljnt{ctx'}  \!,  \ljmv{dcl'}  \!) \, \!\in\! \, \ljcomp{(\!  \ljnt{ctx_{\ljmv{k}}}  \!,  \ljmv{dcl_{\ljmv{k}}}  \!)}{\ljmv{k}}}%
}{
\ljnt{P}  \vdash  \tau  \!\!\prec\!   \ljnt{ctx'} \hspace{-.1ex}.\hspace{-.1ex} \ljmv{dcl'} }{%
{\ljdrulestyXXdclName}{}%
}}

\newcommand{\ljdefnstyXXone}[1]{\begin{ljdefnblock}[#1]{$\ljnt{P}  \vdash  \tau  \!\!\prec\!  \tau'$}{\ljcom{subtyping}}
\ljusedrule{\ljdrulestyXXobj{}}
\ljusedrule{\ljdrulestyXXdcl{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsstyXXoneXXdef}{
\ljdefnstyXXone{}}

% defns sty_many_def
%% defn many
\newcommand{\ljdrulestyXXmanyName}[0]{\ljdrulename{sty\_many}}
\newcommand{\ljdrulestyXXmany}[1]{\ljdrule[#1]{%
\ljpremise{\overline{\tau}  \!=\!  \ljcomp{\tau_{\ljmv{k}}}{\ljmv{k}}}%
\ljpremise{\overline{\tau}'  \!=\!  \ljcomp{\tau'_{\ljmv{k}}}{\ljmv{k}}}%
\ljpremise{\ljcomp{\ljnt{P}  \vdash  \tau_{\ljmv{k}}  \!\!\prec\!  \tau'_{\ljmv{k}}}{\ljmv{k}}}%
}{
\ljnt{P}  \vdash  \overline{\tau}  \!\!\prec\!  \overline{\tau}'}{%
{\ljdrulestyXXmanyName}{}%
}}

\newcommand{\ljdefnstyXXmany}[1]{\begin{ljdefnblock}[#1]{$\ljnt{P}  \vdash  \overline{\tau}  \!\!\prec\!  \overline{\tau}'$}{\ljcom{normal, multiple subtyping}}
\ljusedrule{\ljdrulestyXXmany{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsstyXXmanyXXdef}{
\ljdefnstyXXmany{}}

% defns sty_option_def
%% defn option
\newcommand{\ljdrulestyXXoptionName}[0]{\ljdrulename{sty\_option}}
\newcommand{\ljdrulestyXXoption}[1]{\ljdrule[#1]{%
\ljpremise{{ \tau_{opt} }  \!=\!  \tau}%
\ljpremise{{ \tau_{opt} }'  \!=\!  \tau'}%
\ljpremise{\ljnt{P}  \vdash  \tau  \!\!\prec\!  \tau'}%
}{
\ljnt{P}  \vdash  { \tau_{opt} }  \!\!\prec\!  { \tau_{opt} }'}{%
{\ljdrulestyXXoptionName}{}%
}}

\newcommand{\ljdefnstyXXoption}[1]{\begin{ljdefnblock}[#1]{$\ljnt{P}  \vdash  { \tau_{opt} }  \!\!\prec\!  { \tau_{opt} }'$}{\ljcom{option subtyping}}
\ljusedrule{\ljdrulestyXXoption{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsstyXXoptionXXdef}{
\ljdefnstyXXoption{}}

% defns well_formedness
%% defn object
\newcommand{\ljdrulewfXXnullName}[0]{\ljdrulename{wf\_null}}
\newcommand{\ljdrulewfXXnull}[1]{\ljdrule[#1]{%
\ljpremise{{ \tau_{opt} }  \!=\!  \tau}%
}{
\ljnt{P}  \!,  \ljnt{H}  \vdash  \ljkw{null}  \!\!\prec\!  { \tau_{opt} }}{%
{\ljdrulewfXXnullName}{}%
}}


\newcommand{\ljdrulewfXXobjectName}[0]{\ljdrulename{wf\_object}}
\newcommand{\ljdrulewfXXobject}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{P}  \vdash  \ljnt{H}  (\!  \ljmv{oid}  \!)  \!\!\prec\!  { \tau_{opt} }}%
}{
\ljnt{P}  \!,  \ljnt{H}  \vdash  \ljmv{oid}  \!\!\prec\!  { \tau_{opt} }}{%
{\ljdrulewfXXobjectName}{}%
}}

\newcommand{\ljdefnwfXXobject}[1]{\begin{ljdefnblock}[#1]{$\ljnt{P}  \!,  \ljnt{H}  \vdash  { v_{opt} }  \!\!\prec\!  { \tau_{opt} }$}{\ljcom{well-formed value}}
\ljusedrule{\ljdrulewfXXnull{}}
\ljusedrule{\ljdrulewfXXobject{}}
\end{ljdefnblock}}

%% defn varstate
\newcommand{\ljdrulewfXXvarstateName}[0]{\ljdrulename{wf\_varstate}}
\newcommand{\ljdrulewfXXvarstate}[1]{\ljdrule[#1]{%
\ljpremise{\texttt{\textcolor{red}{<<multiple parses>>}}}%
}{
\ljnt{P}  \!,  \Gamma  \!,  \ljnt{H}  \vdash  \ljnt{L}}{%
{\ljdrulewfXXvarstateName}{}%
}}

\newcommand{\ljdefnwfXXvarstate}[1]{\begin{ljdefnblock}[#1]{$\ljnt{P}  \!,  \Gamma  \!,  \ljnt{H}  \vdash  \ljnt{L}$}{\ljcom{well-formed variable state}}
\ljusedrule{\ljdrulewfXXvarstate{}}
\end{ljdefnblock}}

%% defn heap
\newcommand{\ljdrulewfXXheapName}[0]{\ljdrulename{wf\_heap}}
\newcommand{\ljdrulewfXXheap}[1]{\ljdrule[#1]{%
\ljpremise{\texttt{\textcolor{red}{<<multiple parses>>}}}%
}{
\ljnt{P}  \vdash  \ljnt{H}}{%
{\ljdrulewfXXheapName}{}%
}}

\newcommand{\ljdefnwfXXheap}[1]{\begin{ljdefnblock}[#1]{$\ljnt{P}  \vdash  \ljnt{H}$}{\ljcom{well-formed heap}}
\ljusedrule{\ljdrulewfXXheap{}}
\end{ljdefnblock}}

%% defn config
\newcommand{\ljdrulewfXXallXXexName}[0]{\ljdrulename{wf\_all\_ex}}
\newcommand{\ljdrulewfXXallXXex}[1]{\ljdrule[#1]{%
}{
\Gamma  \vdash  (\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljnt{Exception}  \!)}{%
{\ljdrulewfXXallXXexName}{}%
}}


\newcommand{\ljdrulewfXXallName}[0]{\ljdrulename{wf\_all}}
\newcommand{\ljdrulewfXXall}[1]{\ljdrule[#1]{%
\ljpremise{\vdash  \ljnt{P}}%
\ljpremise{\ljnt{P}  \vdash  \ljnt{H}}%
\ljpremise{\ljnt{P}  \!,  \Gamma  \!,  \ljnt{H}  \vdash  \ljnt{L}}%
\ljpremise{\ljcomp{\ljnt{P}  \!,  \Gamma  \vdash  \ljnt{s_{\ljmv{k}}}}{\ljmv{k}}}%
}{
\Gamma  \vdash  (\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!, \, \ljcomp{\ljnt{s_{\ljmv{k}}}}{\ljmv{k}} \, \!)}{%
{\ljdrulewfXXallName}{}%
}}

\newcommand{\ljdefnwfXXconfig}[1]{\begin{ljdefnblock}[#1]{$\Gamma  \vdash  \ljnt{config}$}{\ljcom{well-formed configuration}}
\ljusedrule{\ljdrulewfXXallXXex{}}
\ljusedrule{\ljdrulewfXXall{}}
\end{ljdefnblock}}

%% defn stmt
\newcommand{\ljdrulewfXXblockName}[0]{\ljdrulename{wf\_block}}
\newcommand{\ljdrulewfXXblock}[1]{\ljdrule[#1]{%
\ljpremise{\ljcomp{\ljnt{P}  \!,  \Gamma  \vdash  \ljnt{s_{\ljmv{k}}}}{\ljmv{k}}}%
}{
\ljnt{P}  \!,  \Gamma  \vdash  \ljsym{\{} \, \ljcomp{\ljnt{s_{\ljmv{k}}}}{\ljmv{k}} \, \ljsym{\}}}{%
{\ljdrulewfXXblockName}{}%
}}


\newcommand{\ljdrulewfXXvarXXassignName}[0]{\ljdrulename{wf\_var\_assign}}
\newcommand{\ljdrulewfXXvarXXassign}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{P}  \vdash  \Gamma  (\!  \ljnt{x}  \!)  \!\!\prec\!  \Gamma  (\!  \ljmv{var}  \!)}%
}{
\ljnt{P}  \!,  \Gamma  \vdash  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{;}}{%
{\ljdrulewfXXvarXXassignName}{}%
}}


\newcommand{\ljdrulewfXXfieldXXreadName}[0]{\ljdrulename{wf\_field\_read}}
\newcommand{\ljdrulewfXXfieldXXread}[1]{\ljdrule[#1]{%
\ljpremise{\Gamma  (\!  \ljnt{x}  \!)  \!=\!  \tau}%
\ljpremise{\ljkw{ftype} \, (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{f}  \!)  \!=\!  \tau'}%
\ljpremise{\ljnt{P}  \vdash  \tau'  \!\!\prec\!  \Gamma  (\!  \ljmv{var}  \!)}%
}{
\ljnt{P}  \!,  \Gamma  \vdash  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{f}  \ljsym{;}}{%
{\ljdrulewfXXfieldXXreadName}{}%
}}


\newcommand{\ljdrulewfXXfieldXXwriteName}[0]{\ljdrulename{wf\_field\_write}}
\newcommand{\ljdrulewfXXfieldXXwrite}[1]{\ljdrule[#1]{%
\ljpremise{\Gamma  (\!  \ljnt{x}  \!)  \!=\!  \tau}%
\ljpremise{\ljkw{ftype} \, (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{f}  \!)  \!=\!  \tau'}%
\ljpremise{\ljnt{P}  \vdash  \Gamma  (\!  \ljnt{y}  \!)  \!\!\prec\!  \tau'}%
}{
\ljnt{P}  \!,  \Gamma  \vdash  \ljnt{x}  \ljsym{.}  \ljmv{f}  \!=\!  \ljnt{y}  \ljsym{;}}{%
{\ljdrulewfXXfieldXXwriteName}{}%
}}


\newcommand{\ljdrulewfXXifName}[0]{\ljdrulename{wf\_if}}
\newcommand{\ljdrulewfXXif}[1]{\ljdrule[#1]{%
\ljpremise{\texttt{\textcolor{red}{<<multiple parses>>}}}%
\ljpremise{\ljnt{P}  \!,  \Gamma  \vdash  \ljnt{s_{{\mathrm{1}}}}}%
\ljpremise{\ljnt{P}  \!,  \Gamma  \vdash  \ljnt{s_{{\mathrm{2}}}}}%
}{
\ljnt{P}  \!,  \Gamma  \vdash  \ljkw{if} \, (\!  \ljnt{x}  \!==\!  \ljnt{y}  \!)  \ljnt{s_{{\mathrm{1}}}} \, \ljkw{else} \, \ljnt{s_{{\mathrm{2}}}}}{%
{\ljdrulewfXXifName}{}%
}}


\newcommand{\ljdrulewfXXmcallName}[0]{\ljdrulename{wf\_mcall}}
\newcommand{\ljdrulewfXXmcall}[1]{\ljdrule[#1]{%
\ljpremise{\overline{y}  \!=\!  \ljcomp{\ljnt{y_{\ljmv{k}}}}{\ljmv{k}}}%
\ljpremise{\Gamma  (\!  \ljnt{x}  \!)  \!=\!  \tau}%
\ljpremise{\ljkw{mtype} \, (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  \ljcomp{\tau_{\ljmv{k}}}{\ljmv{k}}  \rightarrow  \tau'}%
\ljpremise{\ljcomp{\ljnt{P}  \vdash  \Gamma  (\!  \ljnt{y_{\ljmv{k}}}  \!)  \!\!\prec\!  \tau_{\ljmv{k}}}{\ljmv{k}}}%
\ljpremise{\ljnt{P}  \vdash  \tau'  \!\!\prec\!  \Gamma  (\!  \ljmv{var}  \!)}%
}{
\ljnt{P}  \!,  \Gamma  \vdash  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{meth}  (\!  \overline{y}  \!)  \ljsym{;}}{%
{\ljdrulewfXXmcallName}{}%
}}


\newcommand{\ljdrulewfXXnewName}[0]{\ljdrulename{wf\_new}}
\newcommand{\ljdrulewfXXnew}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl}  \!)  \!=\!  \tau}%
\ljpremise{\ljnt{P}  \vdash  \tau  \!\!\prec\!  \Gamma  (\!  \ljmv{var}  \!)}%
}{
\ljnt{P}  \!,  \Gamma  \vdash   \ljmv{var} = \ljkw{new} _{ \ljnt{ctx} } \ljnt{cl} (); }{%
{\ljdrulewfXXnewName}{}%
}}

\newcommand{\ljdefnwfXXstmt}[1]{\begin{ljdefnblock}[#1]{$\ljnt{P}  \!,  \Gamma  \vdash  \ljnt{s}$}{\ljcom{well-formed statement}}
\ljusedrule{\ljdrulewfXXblock{}}
\ljusedrule{\ljdrulewfXXvarXXassign{}}
\ljusedrule{\ljdrulewfXXfieldXXread{}}
\ljusedrule{\ljdrulewfXXfieldXXwrite{}}
\ljusedrule{\ljdrulewfXXif{}}
\ljusedrule{\ljdrulewfXXmcall{}}
\ljusedrule{\ljdrulewfXXnew{}}
\end{ljdefnblock}}

%% defn meth
\newcommand{\ljdrulewfXXmethodName}[0]{\ljdrulename{wf\_method}}
\newcommand{\ljdrulewfXXmethod}[1]{\ljdrule[#1]{%
\ljpremise{\ljkw{distinct} \, (\! \, \ljcomp{\ljmv{var_{\ljmv{k}}}}{\ljmv{k}} \, \!)}%
\ljpremise{\ljcomp{\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl_{\ljmv{k}}}  \!)  \!=\!  \tau_{\ljmv{k}}}{\ljmv{k}}}%
\ljpremise{\Gamma  \!=\!  [\! \, \ljcomp{\ljmv{var_{\ljmv{k}}}  \mapsto  \tau_{\ljmv{k}}}{\ljmv{k}} \, \!]  [\!  \ljkw{this}  \mapsto   \ljnt{ctx} \hspace{-.1ex}.\hspace{-.1ex} \ljmv{dcl}   \!]}%
\ljpremise{\ljcomp{\ljnt{P}  \!,  \Gamma  \vdash  \ljnt{s_{\ljmv{l}}}}{\ljmv{l}}}%
\ljpremise{\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl}  \!)  \!=\!  \tau}%
\ljpremise{\ljnt{P}  \vdash  \Gamma  (\!  \ljnt{y}  \!)  \!\!\prec\!  \tau}%
}{
 \ljnt{P} \vdash _{  \ljnt{ctx} \hspace{-.1ex}.\hspace{-.1ex} \ljmv{dcl}  }  \ljnt{cl} \, \ljmv{meth}  (\!  \ljcomp{\ljnt{cl_{\ljmv{k}}} \, \ljmv{var_{\ljmv{k}}}}{\ljmv{k}}  \!)  \ljsym{\{}  \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \ljkw{return} \, \ljnt{y}  \ljsym{;}  \ljsym{\}} }{%
{\ljdrulewfXXmethodName}{}%
}}

\newcommand{\ljdefnwfXXmeth}[1]{\begin{ljdefnblock}[#1]{$ \ljnt{P} \vdash _{ \tau }  \ljnt{meth\_def} $}{\ljcom{well-formedness of method in $\tau$}}
\ljusedrule{\ljdrulewfXXmethod{}}
\end{ljdefnblock}}

%% defn class_common
\newcommand{\ljdrulewfXXclassXXcommonName}[0]{\ljdrulename{wf\_class\_common}}
\newcommand{\ljdrulewfXXclassXXcommon}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl}  \!)  \!=\!  \tau}%
\ljpremise{ \ljnt{ctx} \hspace{-.1ex}.\hspace{-.1ex} \ljmv{dcl}   \neq  \tau}%
\ljpremise{\ljkw{distinct} \, (\! \, \ljcomp{\ljmv{f_{\ljmv{j}}}}{\ljmv{j}} \, \!)}%
\ljpremise{\ljkw{fields} \, (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \overline{f}}%
\ljpremise{\ljcomp{\ljmv{f_{\ljmv{j}}}}{\ljmv{j}} \, \bot \, \overline{f}}%
\ljpremise{\ljcomp{\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl_{\ljmv{j}}}  \!)  \!=\!  \tau_{\ljmv{j}}}{\ljmv{j}}}%
\ljpremise{\ljcomp{ \ljnt{P} \vdash _{  \ljnt{ctx} \hspace{-.1ex}.\hspace{-.1ex} \ljmv{dcl}  }  \ljnt{meth\_def_{\ljmv{k}}} }{\ljmv{k}}}%
\ljpremise{\ljcomp{\ljkw{methodname} \, (\!  \ljnt{meth\_def_{\ljmv{k}}}  \!)  \!=\!  \ljmv{meth_{\ljmv{k}}}}{\ljmv{k}}}%
\ljpremise{\ljkw{methods} \, (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \ljcomp{\ljmv{meth'_{\ljmv{l}}}}{\ljmv{l}}}%
\ljpremise{\ljcomp{\ljkw{mtype} \, (\!  \ljnt{P}  \!,   \ljnt{ctx} \hspace{-.1ex}.\hspace{-.1ex} \ljmv{dcl}   \!,  \ljmv{meth'_{\ljmv{l}}}  \!)  \!=\!  \pi_{\ljmv{l}}}{\ljmv{l}}}%
\ljpremise{\ljcomp{\ljkw{mtype} \, (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth'_{\ljmv{l}}}  \!)  \!=\!  \pi'_{\ljmv{l}}}{\ljmv{l}}}%
\ljpremise{\texttt{\textcolor{red}{<<multiple parses>>}}}%
}{
 \ljnt{P} \vdash _{ \ljnt{ctx} }( \ljmv{dcl} , \ljnt{cl} , \ljcomp{\ljnt{cl_{\ljmv{j}}} \, \ljmv{f_{\ljmv{j}}}  \ljsym{;}}{\ljmv{j}} , \ljcomp{\ljnt{meth\_def_{\ljmv{k}}}}{\ljmv{k}} ) }{%
{\ljdrulewfXXclassXXcommonName}{}%
}}

\newcommand{\ljdefnwfXXclassXXcommon}[1]{\begin{ljdefnblock}[#1]{$ \ljnt{P} \vdash _{ \ljnt{ctx} }( \ljmv{dcl} , \ljnt{cl} , \overline{fd} , \overline{meth\_def} ) $}{\ljcom{common well-formedness of class in $\ljnt{ctx}$}}
\ljusedrule{\ljdrulewfXXclassXXcommon{}}
\end{ljdefnblock}}

%% defn class
\newcommand{\ljdrulewfXXclassName}[0]{\ljdrulename{wf\_class}}
\newcommand{\ljdrulewfXXclass}[1]{\ljdrule[#1]{%
\ljpremise{\ljkw{class} \, \ljmv{dcl} \, \ljkw{extends} \, \ljnt{cl}  \ljsym{\{}  \overline{fd} \, \overline{meth\_def}  \ljsym{\}} \, \!\in\! \, \ljnt{P}}%
\ljpremise{ \ljnt{P} \vdash _{ \ljnt{ctx} }( \ljmv{dcl} , \ljnt{cl} , \overline{fd} , \overline{meth\_def} ) }%
}{
\ljnt{P}  \vdash  \ljkw{class} \, \ljmv{dcl} \, \ljkw{extends} \, \ljnt{cl}  \ljsym{\{}  \overline{fd} \, \overline{meth\_def}  \ljsym{\}}}{%
{\ljdrulewfXXclassName}{}%
}}

\newcommand{\ljdefnwfXXclass}[1]{\begin{ljdefnblock}[#1]{$\ljnt{P}  \vdash  \ljnt{cld}$}{\ljcom{well-formed class}}
\ljusedrule{\ljdrulewfXXclass{}}
\end{ljdefnblock}}

%% defn program
\newcommand{\ljdrulewfXXprogramName}[0]{\ljdrulename{wf\_program}}
\newcommand{\ljdrulewfXXprogram}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{P}  \!=\!  \ljcomp{\ljnt{cld_{\ljmv{k}}}}{\ljmv{k}}}%
\ljpremise{\ljsym{distinct\_names}  (\!  \ljnt{P}  \!)}%
\ljpremise{\ljcomp{\ljnt{P}  \vdash  \ljnt{cld_{\ljmv{k}}}}{\ljmv{k}}}%
}{
\vdash  \ljnt{P}}{%
{\ljdrulewfXXprogramName}{}%
}}

\newcommand{\ljdefnwfXXprogram}[1]{\begin{ljdefnblock}[#1]{$\vdash  \ljnt{P}$}{\ljcom{well-formed program}}
\ljusedrule{\ljdrulewfXXprogram{}}
\end{ljdefnblock}}


\newcommand{\ljdefnswellXXformedness}{
\ljdefnwfXXobject{}\ljdefnwfXXvarstate{}\ljdefnwfXXheap{}\ljdefnwfXXconfig{}\ljdefnwfXXstmt{}\ljdefnwfXXmeth{}\ljdefnwfXXclassXXcommon{}\ljdefnwfXXclass{}\ljdefnwfXXprogram{}}

% defns var_trans
%% defn tr_s
\newcommand{\ljdruletrXXsXXvarXXassignName}[0]{\ljdrulename{tr\_s\_var\_assign}}
\newcommand{\ljdruletrXXsXXvarXXassign}[1]{\ljdrule[#1]{%
\ljpremise{\theta  (\!  \ljmv{var}  \!)  \!=\!  \ljmv{var'}}%
\ljpremise{\theta  (\!  \ljnt{x}  \!)  \!=\!  \ljnt{x'}}%
}{
\theta  \vdash  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{;}  \leadsto  \ljmv{var'}  \!=\!  \ljnt{x'}  \ljsym{;}}{%
{\ljdruletrXXsXXvarXXassignName}{}%
}}


\newcommand{\ljdruletrXXsXXifName}[0]{\ljdrulename{tr\_s\_if}}
\newcommand{\ljdruletrXXsXXif}[1]{\ljdrule[#1]{%
\ljpremise{\theta  (\!  \ljnt{x}  \!)  \!=\!  \ljnt{x'}}%
\ljpremise{\theta  (\!  \ljnt{y}  \!)  \!=\!  \ljnt{y'}}%
\ljpremise{\theta  \vdash  \ljnt{s_{{\mathrm{1}}}}  \leadsto  \ljnt{s'_{{\mathrm{1}}}}}%
\ljpremise{\theta  \vdash  \ljnt{s_{{\mathrm{2}}}}  \leadsto  \ljnt{s'_{{\mathrm{2}}}}}%
}{
\theta  \vdash  \ljkw{if} \, (\!  \ljnt{x}  \!==\!  \ljnt{y}  \!)  \ljnt{s_{{\mathrm{1}}}} \, \ljkw{else} \, \ljnt{s_{{\mathrm{2}}}}  \leadsto  \ljkw{if} \, (\!  \ljnt{x'}  \!==\!  \ljnt{y'}  \!)  \ljnt{s'_{{\mathrm{1}}}} \, \ljkw{else} \, \ljnt{s'_{{\mathrm{2}}}}}{%
{\ljdruletrXXsXXifName}{}%
}}


\newcommand{\ljdruletrXXsXXblockName}[0]{\ljdrulename{tr\_s\_block}}
\newcommand{\ljdruletrXXsXXblock}[1]{\ljdrule[#1]{%
\ljpremise{\ljcomp{\theta  \vdash  \ljnt{s_{\ljmv{k}}}  \leadsto  \ljnt{s'_{\ljmv{k}}}}{\ljmv{k}}}%
}{
\theta  \vdash  \ljsym{\{} \, \ljcomp{\ljnt{s_{\ljmv{k}}}}{\ljmv{k}} \, \ljsym{\}}  \leadsto  \ljsym{\{} \, \ljcomp{\ljnt{s'_{\ljmv{k}}}}{\ljmv{k}} \, \ljsym{\}}}{%
{\ljdruletrXXsXXblockName}{}%
}}


\newcommand{\ljdruletrXXsXXnewName}[0]{\ljdrulename{tr\_s\_new}}
\newcommand{\ljdruletrXXsXXnew}[1]{\ljdrule[#1]{%
\ljpremise{\theta  (\!  \ljmv{var}  \!)  \!=\!  \ljmv{var'}}%
}{
\theta  \vdash   \ljmv{var} = \ljkw{new} _{ \ljnt{ctx} } \ljnt{cl} ();   \leadsto   \ljmv{var'} = \ljkw{new} _{ \ljnt{ctx} } \ljnt{cl} (); }{%
{\ljdruletrXXsXXnewName}{}%
}}


\newcommand{\ljdruletrXXsXXfieldXXreadName}[0]{\ljdrulename{tr\_s\_field\_read}}
\newcommand{\ljdruletrXXsXXfieldXXread}[1]{\ljdrule[#1]{%
\ljpremise{\theta  (\!  \ljmv{var}  \!)  \!=\!  \ljmv{var'}}%
\ljpremise{\theta  (\!  \ljnt{x}  \!)  \!=\!  \ljnt{x'}}%
}{
\theta  \vdash  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{f}  \ljsym{;}  \leadsto  \ljmv{var'}  \!=\!  \ljnt{x'}  \ljsym{.}  \ljmv{f}  \ljsym{;}}{%
{\ljdruletrXXsXXfieldXXreadName}{}%
}}


\newcommand{\ljdruletrXXsXXfieldXXwriteName}[0]{\ljdrulename{tr\_s\_field\_write}}
\newcommand{\ljdruletrXXsXXfieldXXwrite}[1]{\ljdrule[#1]{%
\ljpremise{\theta  (\!  \ljnt{x}  \!)  \!=\!  \ljnt{x'}}%
\ljpremise{\theta  (\!  \ljnt{y}  \!)  \!=\!  \ljnt{y'}}%
}{
\theta  \vdash  \ljnt{x}  \ljsym{.}  \ljmv{f}  \!=\!  \ljnt{y}  \ljsym{;}  \leadsto  \ljnt{x'}  \ljsym{.}  \ljmv{f}  \!=\!  \ljnt{y'}  \ljsym{;}}{%
{\ljdruletrXXsXXfieldXXwriteName}{}%
}}


\newcommand{\ljdruletrXXsXXmcallName}[0]{\ljdrulename{tr\_s\_mcall}}
\newcommand{\ljdruletrXXsXXmcall}[1]{\ljdrule[#1]{%
\ljpremise{\theta  (\!  \ljmv{var}  \!)  \!=\!  \ljmv{var'}}%
\ljpremise{\theta  (\!  \ljnt{x}  \!)  \!=\!  \ljnt{x'}}%
\ljpremise{\ljcomp{\theta  (\!  \ljnt{y_{\ljmv{k}}}  \!)  \!=\!  \ljnt{y'_{\ljmv{k}}}}{\ljmv{k}}}%
}{
\theta  \vdash  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{meth}  (\!  \ljcomp{\ljnt{y_{\ljmv{k}}}}{\ljmv{k}}  \!)  \ljsym{;}  \leadsto  \ljmv{var'}  \!=\!  \ljnt{x'}  \ljsym{.}  \ljmv{meth}  (\!  \ljcomp{\ljnt{y'_{\ljmv{k}}}}{\ljmv{k}}  \!)  \ljsym{;}}{%
{\ljdruletrXXsXXmcallName}{}%
}}

\newcommand{\ljdefntrXXs}[1]{\begin{ljdefnblock}[#1]{$\theta  \vdash  \ljnt{s}  \leadsto  \ljnt{s'}$}{\ljcom{variable translation for a statement}}
\ljusedrule{\ljdruletrXXsXXvarXXassign{}}
\ljusedrule{\ljdruletrXXsXXif{}}
\ljusedrule{\ljdruletrXXsXXblock{}}
\ljusedrule{\ljdruletrXXsXXnew{}}
\ljusedrule{\ljdruletrXXsXXfieldXXread{}}
\ljusedrule{\ljdruletrXXsXXfieldXXwrite{}}
\ljusedrule{\ljdruletrXXsXXmcall{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsvarXXtrans}{
\ljdefntrXXs{}}

% defns reduction
%% defn stmt
\newcommand{\ljdrulerXXfieldXXreadXXnpeName}[0]{\ljdrulename{r\_field\_read\_npe}}
\newcommand{\ljdrulerXXfieldXXreadXXnpe}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{L}  (\!  \ljnt{x}  \!)  \!=\!  \ljkw{null}}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{f}  \ljsym{;} \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljkw{NPE}  \!)}{%
{\ljdrulerXXfieldXXreadXXnpeName}{}%
}}


\newcommand{\ljdrulerXXfieldXXwriteXXnpeName}[0]{\ljdrulename{r\_field\_write\_npe}}
\newcommand{\ljdrulerXXfieldXXwriteXXnpe}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{L}  (\!  \ljnt{x}  \!)  \!=\!  \ljkw{null}}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljnt{x}  \ljsym{.}  \ljmv{f}  \!=\!  \ljnt{y}  \ljsym{;} \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljkw{NPE}  \!)}{%
{\ljdrulerXXfieldXXwriteXXnpeName}{}%
}}


\newcommand{\ljdrulerXXvarXXassignName}[0]{\ljdrulename{r\_var\_assign}}
\newcommand{\ljdrulerXXvarXXassign}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{L}  (\!  \ljnt{x}  \!)  \!=\!  \ljnt{v}}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{;} \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  [\!  \ljmv{var}  \mapsto  \ljnt{v}  \!]  \!,  \ljnt{H}  \!, \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)}{%
{\ljdrulerXXvarXXassignName}{}%
}}


\newcommand{\ljdrulerXXfieldXXreadName}[0]{\ljdrulename{r\_field\_read}}
\newcommand{\ljdrulerXXfieldXXread}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{L}  (\!  \ljnt{x}  \!)  \!=\!  \ljmv{oid}}%
\ljpremise{\ljnt{H}  (\!  \ljmv{oid}  \!,  \ljmv{f}  \!)  \!=\!  \ljnt{v}}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{f}  \ljsym{;} \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  [\!  \ljmv{var}  \mapsto  \ljnt{v}  \!]  \!,  \ljnt{H}  \!, \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)}{%
{\ljdrulerXXfieldXXreadName}{}%
}}


\newcommand{\ljdrulerXXfieldXXwriteName}[0]{\ljdrulename{r\_field\_write}}
\newcommand{\ljdrulerXXfieldXXwrite}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{L}  (\!  \ljnt{x}  \!)  \!=\!  \ljmv{oid}}%
\ljpremise{\ljnt{L}  (\!  \ljnt{y}  \!)  \!=\!  \ljnt{v}}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljnt{x}  \ljsym{.}  \ljmv{f}  \!=\!  \ljnt{y}  \ljsym{;} \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  [\!  (\!  \ljmv{oid}  \!,  \ljmv{f}  \!)  \mapsto  \ljnt{v}  \!]  \!, \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)}{%
{\ljdrulerXXfieldXXwriteName}{}%
}}


\newcommand{\ljdrulerXXmcallXXnpeName}[0]{\ljdrulename{r\_mcall\_npe}}
\newcommand{\ljdrulerXXmcallXXnpe}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{L}  (\!  \ljnt{x}  \!)  \!=\!  \ljkw{null}}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{meth}  (\!  \ljcomp{\ljnt{y_{\ljmv{k}}}}{\ljmv{k}}  \!)  \ljsym{;} \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljkw{NPE}  \!)}{%
{\ljdrulerXXmcallXXnpeName}{}%
}}


\newcommand{\ljdrulerXXmcallXXcnfeName}[0]{\ljdrulename{r\_mcall\_cnfe}}
\newcommand{\ljdrulerXXmcallXXcnfe}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{L}  (\!  \ljnt{x}  \!)  \!=\!  \ljmv{oid}}%
\ljpremise{\ljnt{H}  (\!  \ljmv{oid}  \!)  \!=\!  \tau}%
\ljpremise{\ljsym{find\_meth\_def}  (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  \ljkw{null}}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{meth}  (\!  \ljcomp{\ljnt{y_{\ljmv{k}}}}{\ljmv{k}}  \!)  \ljsym{;} \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljkw{CNFE}  \!)}{%
{\ljdrulerXXmcallXXcnfeName}{}%
}}


\newcommand{\ljdrulerXXifXXtrueName}[0]{\ljdrulename{r\_if\_true}}
\newcommand{\ljdrulerXXifXXtrue}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{L}  (\!  \ljnt{x}  \!)  \!=\!  \ljnt{v}}%
\ljpremise{\ljnt{L}  (\!  \ljnt{y}  \!)  \!=\!  \ljnt{w}}%
\ljpremise{\ljnt{v}  \!==\!  \ljnt{w}}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljkw{if} \, (\!  \ljnt{x}  \!==\!  \ljnt{y}  \!)  \ljnt{s_{{\mathrm{1}}}} \, \ljkw{else} \, \ljnt{s_{{\mathrm{2}}}} \, \ljcomp{\ljnt{s'_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljnt{s_{{\mathrm{1}}}} \, \ljcomp{\ljnt{s'_{\ljmv{l}}}}{\ljmv{l}} \, \!)}{%
{\ljdrulerXXifXXtrueName}{}%
}}


\newcommand{\ljdrulerXXifXXfalseName}[0]{\ljdrulename{r\_if\_false}}
\newcommand{\ljdrulerXXifXXfalse}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{L}  (\!  \ljnt{x}  \!)  \!=\!  \ljnt{v}}%
\ljpremise{\ljnt{L}  (\!  \ljnt{y}  \!)  \!=\!  \ljnt{w}}%
\ljpremise{\ljnt{v}  \neq  \ljnt{w}}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljkw{if} \, (\!  \ljnt{x}  \!==\!  \ljnt{y}  \!)  \ljnt{s_{{\mathrm{1}}}} \, \ljkw{else} \, \ljnt{s_{{\mathrm{2}}}} \, \ljcomp{\ljnt{s'_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljnt{s_{{\mathrm{2}}}} \, \ljcomp{\ljnt{s'_{\ljmv{l}}}}{\ljmv{l}} \, \!)}{%
{\ljdrulerXXifXXfalseName}{}%
}}


\newcommand{\ljdrulerXXblockName}[0]{\ljdrulename{r\_block}}
\newcommand{\ljdrulerXXblock}[1]{\ljdrule[#1]{%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljsym{\{} \, \ljcomp{\ljnt{s_{\ljmv{k}}}}{\ljmv{k}} \, \ljsym{\}} \, \ljcomp{\ljnt{s'_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!, \, \ljcomp{\ljnt{s_{\ljmv{k}}}}{\ljmv{k}} \, \ljcomp{\ljnt{s'_{\ljmv{l}}}}{\ljmv{l}} \, \!)}{%
{\ljdrulerXXblockName}{}%
}}


\newcommand{\ljdrulerXXnewName}[0]{\ljdrulename{r\_new}}
\newcommand{\ljdrulerXXnew}[1]{\ljdrule[#1]{%
\ljpremise{\ljsym{find\_type}  (\!  \ljnt{P}  \!,  \ljnt{ctx}  \!,  \ljnt{cl}  \!)  \!=\!  \tau}%
\ljpremise{\ljkw{fields} \, (\!  \ljnt{P}  \!,  \tau  \!)  \!=\!  \ljcomp{\ljmv{f_{\ljmv{k}}}}{\ljmv{k}}}%
\ljpremise{\ljmv{oid} \, \!\notin\! \, \ljkw{dom} \, (\!  \ljnt{H}  \!)}%
\ljpremise{\ljnt{H'}  \!=\!  \ljnt{H}  [\!  \ljmv{oid}  \mapsto  (\!  \tau  \!, \, \ljcomp{\ljmv{f_{\ljmv{k}}}  \mapsto  \ljkw{null}}{\ljmv{k}} \, \!)  \!]}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,   \ljmv{var} = \ljkw{new} _{ \ljnt{ctx} } \ljnt{cl} ();  \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L}  [\!  \ljmv{var}  \mapsto  \ljmv{oid}  \!]  \!,  \ljnt{H'}  \!, \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)}{%
{\ljdrulerXXnewName}{}%
}}


\newcommand{\ljdrulerXXmcallName}[0]{\ljdrulename{r\_mcall}}
\newcommand{\ljdrulerXXmcall}[1]{\ljdrule[#1]{%
\ljpremise{\ljnt{L}  (\!  \ljnt{x}  \!)  \!=\!  \ljmv{oid}}%
\ljpremise{\ljnt{H}  (\!  \ljmv{oid}  \!)  \!=\!  \tau}%
\ljpremise{\ljsym{find\_meth\_def}  (\!  \ljnt{P}  \!,  \tau  \!,  \ljmv{meth}  \!)  \!=\!  (\!  \ljnt{ctx}  \!,  \ljnt{cl} \, \ljmv{meth}  (\!  \ljcomp{\ljnt{cl_{\ljmv{k}}} \, \ljmv{var_{\ljmv{k}}}}{\ljmv{k}}  \!)  \ljsym{\{}  \ljcomp{\ljnt{s'_{\ljmv{j}}}}{\ljmv{j}} \, \ljkw{return} \, \ljnt{y}  \ljsym{;}  \ljsym{\}}  \!)}%
\ljpremise{\ljcomp{\ljmv{var'_{\ljmv{k}}}}{\ljmv{k}} \, \bot \, \ljkw{dom} \, (\!  \ljnt{L}  \!)}%
\ljpremise{\ljkw{distinct} \, (\! \, \ljcomp{\ljmv{var'_{\ljmv{k}}}}{\ljmv{k}} \, \!)}%
\ljpremise{\ljnt{x'} \, \!\notin\! \, \ljkw{dom} \, (\!  \ljnt{L}  \!)}%
\ljpremise{\ljnt{x'} \, \!\notin\! \, \ljcomp{\ljmv{var'_{\ljmv{k}}}}{\ljmv{k}}}%
\ljpremise{\ljcomp{\ljnt{L}  (\!  \ljnt{y_{\ljmv{k}}}  \!)  \!=\!  \ljnt{v_{\ljmv{k}}}}{\ljmv{k}}}%
\ljpremise{\ljnt{L'}  \!=\!  \ljnt{L}  [\! \, \ljcomp{\ljmv{var'_{\ljmv{k}}}  \mapsto  \ljnt{v_{\ljmv{k}}}}{\ljmv{k}} \, \!]  [\!  \ljnt{x'}  \mapsto  \ljmv{oid}  \!]}%
\ljpremise{\theta  \!=\!  [\! \, \ljcomp{\ljmv{var_{\ljmv{k}}}  \mapsto  \ljmv{var'_{\ljmv{k}}}}{\ljmv{k}} \, \!]  [\!  \ljkw{this}  \mapsto  \ljnt{x'}  \!]}%
\ljpremise{\ljcomp{\theta  \vdash  \ljnt{s'_{\ljmv{j}}}  \leadsto  \ljnt{s''_{\ljmv{j}}}}{\ljmv{j}}}%
\ljpremise{\theta  (\!  \ljnt{y}  \!)  \!=\!  \ljnt{y'}}%
}{
(\!  \ljnt{P}  \!,  \ljnt{L}  \!,  \ljnt{H}  \!,  \ljmv{var}  \!=\!  \ljnt{x}  \ljsym{.}  \ljmv{meth}  (\!  \ljcomp{\ljnt{y_{\ljmv{k}}}}{\ljmv{k}}  \!)  \ljsym{;} \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)  \longrightarrow  (\!  \ljnt{P}  \!,  \ljnt{L'}  \!,  \ljnt{H}  \!, \, \ljcomp{\ljnt{s''_{\ljmv{j}}}}{\ljmv{j}} \, \ljmv{var}  \!=\!  \ljnt{y'}  \ljsym{;} \, \ljcomp{\ljnt{s_{\ljmv{l}}}}{\ljmv{l}} \, \!)}{%
{\ljdrulerXXmcallName}{}%
}}

\newcommand{\ljdefnrXXstmt}[1]{\begin{ljdefnblock}[#1]{$\ljnt{config}  \longrightarrow  \ljnt{config'}$}{\ljcom{one step reduction}}
\ljusedrule{\ljdrulerXXfieldXXreadXXnpe{}}
\ljusedrule{\ljdrulerXXfieldXXwriteXXnpe{}}
\ljusedrule{\ljdrulerXXvarXXassign{}}
\ljusedrule{\ljdrulerXXfieldXXread{}}
\ljusedrule{\ljdrulerXXfieldXXwrite{}}
\ljusedrule{\ljdrulerXXmcallXXnpe{}}
\ljusedrule{\ljdrulerXXmcallXXcnfe{}}
\ljusedrule{\ljdrulerXXifXXtrue{}}
\ljusedrule{\ljdrulerXXifXXfalse{}}
\ljusedrule{\ljdrulerXXblock{}}
\ljusedrule{\ljdrulerXXnew{}}
\ljusedrule{\ljdrulerXXmcall{}}
\end{ljdefnblock}}


\newcommand{\ljdefnsreduction}{
\ljdefnrXXstmt{}}

\newcommand{\ljdefnss}{
\ljdefnsclassnameXXdef
\ljdefnssuperclassXXdef
\ljdefnsclassfieldsXXdef
\ljdefnsclassmethodsXXdef
\ljdefnsmethodnameXXdef
\ljdefnsdistinctXXnamesXXdef
\ljdefnsfindXXcldXXdef
\ljdefnsfindXXtypeXXdef
\ljdefnsfindXXpathXXdef
\ljdefnsfindXXpathXXtyXXdef
\ljdefnsfieldsXXinXXpathXXdef
\ljdefnsfieldsXXdef
\ljdefnsmethodsXXinXXpathXXdef
\ljdefnsmethodsXXdef
\ljdefnsftypeXXinXXfdsXXdef
\ljdefnsftypeXXinXXpathXXdef
\ljdefnsftypeXXdef
\ljdefnsfindXXmethXXdefXXinXXlistXXdef
\ljdefnsfindXXmethXXdefXXinXXpathXXdef
\ljdefnsfindXXmethXXdefXXdef
\ljdefnsmtypeXXdef
\ljdefnsstyXXoneXXdef
\ljdefnsstyXXmanyXXdef
\ljdefnsstyXXoptionXXdef
\ljdefnswellXXformedness
\ljdefnsvarXXtrans
\ljdefnsreduction
}

\newcommand{\ljall}{\ljmetavars\\[0pt]
\ljgrammar\\[5.0mm]
\ljdefnss}

